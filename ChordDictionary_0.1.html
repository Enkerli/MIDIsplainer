import React, { useState, useEffect } from 'react';
import { Card } from '@/components/ui/card';

// First fix: Improve parsing of full names
function parseChordInput(input) {
    input = input.trim();

    // Try full name first (e.g., "C minor seventh")
    const fullNameMatch = input.match(/^([A-G][b#]?)\s+(.+)$/i);
    if (fullNameMatch) {
        const [_, root, description] = fullNameMatch;
        const quality = Object.entries(chordFullNames).find(
            ([_, name]) => name.toLowerCase() === description.toLowerCase()
        );
        if (quality) {
            const basePCS = chordQualities[quality[0]];
            const rootPC = noteToPC[root];
            return {
                quality: quality[0],
                root,
                baseDecimal: parseInt(toBinaryPCS(basePCS), 2),
                pcs: transposePitchClassSet(basePCS, rootPC)
            };
        }
    }

    // Try PCS notation with proper spacing handling
    const pcsMatch = input.match(/\[\s*(\d+(?:\s*,\s*\d+)*)\s*\]/);
    if (pcsMatch) {
        const pcs = pcsMatch[1].split(',').map(n => parseInt(n.trim()));
        return findChordByPCS(pcs);
    }

    // Fix decimal notation parsing for transposed chords
    if (/^\d+$/.test(input)) {
        const decimal = parseInt(input);
        return findChordByDecimal(decimal);
    }

    // Try chord symbol last (e.g., "Cm7")
    const parsed = parseChord(input);
    if (parsed) {
        const { root, quality } = parsed;
        const basePCS = chordQualities[quality];
        if (basePCS) {
            const rootPC = noteToPC[root];
            return {
                quality,
                root,
                baseDecimal: parseInt(toBinaryPCS(basePCS), 2),
                pcs: transposePitchClassSet(basePCS, rootPC)
            };
        }
    }

    return null;
}

// Fix degree ordering logic
function orderByDegrees(pcSet, root = 0) {
    const degreeOrder = [
        0,              // Root
        3, 4,          // Thirds
        6, 7,          // Fifths
        10, 11,        // Sevenths
        1, 2,          // Ninths
        5,             // Eleventh
        8, 9           // Thirteenths
    ];
    
    return [...pcSet].sort((a, b) => {
        const relA = (a - root + 12) % 12;
        const relB = (b - root + 12) % 12;
        const idxA = degreeOrder.indexOf(relA);
        const idxB = degreeOrder.indexOf(relB);
        return (idxA === -1 ? 999 : idxA) - (idxB === -1 ? 999 : idxB);
    });
}

// Fix transposition handling for non-C roots
function getAllTranspositions(pcs, root) {
    const transpositions = {};
    const rootPC = noteToPC[root] || 0;
    
    // Get base version (transposed back to C)
    const basePCS = transposePitchClassSet(pcs, (12 - rootPC) % 12);
    const baseDecimal = parseInt(toBinaryPCS(basePCS), 2);

    // Generate all transpositions
    Object.entries(noteToPC).forEach(([note, pc]) => {
        const transposedPCS = transposePitchClassSet(basePCS, pc);
        const orderedPCS = orderByDegrees(transposedPCS, pc);
        const binary = toBinaryPCS(orderedPCS);
        const decimal = parseInt(binary, 2);
        
        transpositions[note] = {
            pcs: orderedPCS,
            binary,
            decimal
        };
    });

    return { transpositions, baseDecimal };
}

// Add named inversions handling
function findNamedInversions(pcs) {
    const inversions = [];
    const decimal = parseInt(toBinaryPCS(pcs), 2);

    Object.entries(chordQualities).forEach(([quality, qualityPCS]) => {
        if (qualityPCS.length !== pcs.length) return;

        for (let i = 0; i < 12; i++) {
            const transposed = transposePitchClassSet(qualityPCS, i);
            const transposedDecimal = parseInt(toBinaryPCS(transposed), 2);
            
            if (transposedDecimal === decimal && JSON.stringify(transposed) !== JSON.stringify(pcs)) {
                inversions.push({
                    quality,
                    root: noteToPCKeys[i],
                    pcs: transposed
                });
            }
        }
    });

    return inversions;
}

// Add proper avoid notes calculation
function calculateAvoidNotes(quality, pcs) {
    const avoidNotes = new Set();
    
    // Basic rules for avoid notes
    if (quality.includes('maj7')) {
        avoidNotes.add(5); // Perfect fourth (F in C)
    }
    if (quality.includes('min7')) {
        avoidNotes.add(9); // Major sixth (A in C)
    }
    if (quality.includes('7')) {
        avoidNotes.add(5); // Perfect fourth (F in C)
        if (!quality.includes('13')) {
            avoidNotes.add(9); // Major sixth (A in C)
        }
    }

    return Array.from(avoidNotes);
}

// Add compatible scales calculation
function findCompatibleScales(pcs) {
    // Implementation of scale compatibility logic
    // This would check if the chord tones are contained within various scales
    // For now, returning placeholder data
    return ['major', 'lydian']; // To be implemented
}

const ChordDictionary = () => {
    // Component implementation
    return (
        <div className="chord-dictionary w-full max-w-4xl mx-auto">
            {/* UI implementation */}
        </div>
    );
};

export default ChordDictionary;