<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord to Pitch Class Set Converter</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 2rem auto;
            padding: 0 1rem;
        }
        .container {
            background-color: #f5f5f5;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        .input-group {
            margin-bottom: 1rem;
        }
        input {
            padding: 0.5rem;
            font-size: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
            margin-right: 0.5rem;
        }
        button {
            padding: 0.5rem 1rem;
            font-size: 1rem;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background-color: #0056b3;
        }
        #result {
            margin-top: 1rem;
            font-size: 1.1rem;
        }
        .chord-dictionary, .chord-management-section, .export-section {
            margin-top: 2rem;
            padding-top: 2rem;
            border-top: 1px solid #ccc;
        }
        .tabs {
            margin-bottom: 1rem;
        }
        .tab-button {
            padding: 0.5rem 1rem;
            margin-right: 0.5rem;
            border: 1px solid #ccc;
            background: #f5f5f5;
            cursor: pointer;
            border-radius: 4px;
        }
        .tab-button.active {
            background: #007bff;
            color: white;
            border-color: #0056b3;
        }
        .tab-content {
            padding: 1rem;
            background: #f9f9f9;
            border-radius: 4px;
        }
        select {
            width: calc(100% - 1rem);
            margin-bottom: 0.5rem;
        }
        .input-group input, .input-group select {
            margin-bottom: 0.5rem;
            width: calc(100% - 1rem);
        }
        .binary-format {
            font-family: monospace;
            background: #f0f0f0;
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
        }
        select {
            padding: 0.5rem;
            font-size: 1rem;
            margin-bottom: 1rem;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        #chordList {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 1rem;
        }
        .chord-item {
            background-color: white;
            padding: 1rem;
            border-radius: 4px;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .chord-name {
            font-weight: bold;
            margin-bottom: 0.5rem;
        }
        .chord-intervals {
            color: #666;
            font-size: 0.9rem;
        }
        .chord-fullname {
			color: #444;
			font-style: italic;
			margin-bottom: 0.5rem;
		}
		.chord-forte {
			font-family: monospace;
			color: #666;
			background: #f0f0f0;
			padding: 0.2rem 0.4rem;
			border-radius: 3px;
			margin-bottom: 0.5rem;
		}
		.chord-scales, .chord-avoid {
			color: #666;
			font-size: 0.9rem;
			margin-bottom: 0.5rem;
		}

		.chord-scales {
			font-style: italic;
		}

		.chord-avoid {
			color: #d32f2f;
		}
		.result-header {
			display: flex;
			justify-content: space-between;
			align-items: center;
			margin-bottom: 1rem;
		}

		.edit-button, .save-button {
			padding: 0.5rem 1rem;
			font-size: 0.9rem;
			border-radius: 4px;
			cursor: pointer;
		}

		.edit-button {
			background-color: #007bff;
			color: white;
			border: none;
		}

		.save-button {
			background-color: #28a745;
			color: white;
			border: none;
		}

		.result-edit .input-group {
			display: flex;
			flex-direction: column;
			gap: 0.5rem;
		}

		.result-edit .input-group input {
			width: 100%;
			padding: 0.5rem;
			font-size: 1rem;
			border: 1px solid #ccc;
			border-radius: 4px;
		}
    </style>
</head>
<body>
    <div class="container">
        <h1>Chord to Pitch Class Set Converter</h1>
        <div class="input-group">
            <input type="text" id="chordInput" placeholder="Enter chord (e.g., Cmaj7)">
            <button id="convertButton" onclick="convertToPCS()">Convert</button>
        </div>
        <div id="result"></div>

<!-- 
        <div class="chord-management-section">
            <h2>Manage Chord Qualities</h2>
<!~~ 
            <div class="tabs">
                <button onclick="switchTab('add')" class="tab-button active">Add New</button>
                <button onclick="switchTab('edit')" class="tab-button">Edit Existing</button>
            </div>
 ~~>
            
			<div id="addChordTab" class="tab-content">
				<div class="input-group">
					<input type="text" id="newQualityName" placeholder="Quality name (e.g., maj7b5)">
					<input type="text" id="newQualityFullName" placeholder="Full name (e.g., major seventh flat five)">
					<input type="text" id="newQualityForte" placeholder="Forte number (e.g., 4-19A)">
					<input type="text" id="newQualityPCS" placeholder="PCS from C (e.g., 0,4,6,11)">
					<input type="text" id="newQualityAliases" placeholder="Alternate notations (comma-separated)">
					<input type="text" id="newQualityScales" placeholder="Compatible scales (comma-separated)">
					<input type="text" id="newQualityAvoid" placeholder="Avoid notes (comma-separated)">
					<button onclick="addNewChordQuality()">Add Chord Quality</button>
				</div>
			</div>

			<div id="editChordTab" class="tab-content" style="display: none;">
				<div class="input-group">
					<select id="editQualitySelect" onchange="loadChordQuality()">
						<option value="">Select chord quality to edit</option>
					</select>
					<input type="text" id="editQualityFullName" placeholder="Full name (e.g., major seventh flat five)">
					<input type="text" id="editQualityForte" placeholder="Forte number (e.g., 4-19A)">
					<input type="text" id="editQualityPCS" placeholder="PCS from C (e.g., 0,4,6,11)">
					<input type="text" id="editQualityAliases" placeholder="Alternate notations (comma-separated)">
					<input type="text" id="editQualityScales" placeholder="Compatible scales (comma-separated)">
					<input type="text" id="editQualityAvoid" placeholder="Avoid notes (comma-separated)">
					<button onclick="updateChordQuality()">Update Chord Quality</button>
				</div>
			</div>
        </div>
 -->

        
        <div class="export-section">
<!-- 			<h2>Import/Export Chord Dictionary</h2> -->
			<h2>Export Chord Dictionary</h2>
			<button onclick="exportChordDictionary()">Export to JSON</button>
			<!-- 
<button onclick="importChordDictionary()">Import from JSON</button>
			<input type="file" id="jsonFileInput" accept=".json" style="display: none;" onchange="handleFileUpload(event)">
 -->
		</div>


        <div class="chord-dictionary">
            <h2>Chord Dictionary</h2>
            <select id="chordCategory" onchange="filterChordTypes()">
                <option value="all">All Chords</option>
                <option value="triads">Triads</option>
                <option value="seventh">Seventh Chords</option>
                <option value="sixth">Sixth Chords</option>
                <option value="extended">Extended Chords</option>
                <option value="suspended">Suspended Chords</option>
                <option value="altered">Altered Dominants</option>
            </select>
            <div id="chordList"></div>
        </div>
    </div>

    <script>
        const noteToPC = {
            'C': 0, 'C#': 1, 'Db': 1,
            'D': 2, 'D#': 3, 'Eb': 3,
            'E': 4,
            'F': 5, 'F#': 6, 'Gb': 6,
            'G': 7, 'G#': 8, 'Ab': 8,
            'A': 9, 'A#': 10, 'Bb': 10,
            'B': 11
        };

		const noteToPCKeys = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];

        // Alternate notation mappings
		const chordAliases = {
// 			'maj7': ['Δ', 'Δ7', '∆', '∆7', 'M7'],
// 			'maj9': ['Δ9', '∆9', 'M9'],
// 			'maj11': ['Δ11', '∆11', 'M11'],
// 			'maj13': ['Δ13', '∆13', 'M13'],
			'min7': ['-7', 'm7'],
			'min': ['m', '-'],
			'dim': ['°', 'o'],
			'aug': ['+', '+5', '#5'],
// 			'minMaj7': ['mM7', 'm∆7', 'm∆', 'mΔ7', 'mΔ', '-∆7', '-∆'],
		};

		const chordForteNumbers = {
			// Triads (3-note sets)
			'maj': '3-11B',    // (047)
			'min': '3-11A',    // (037)
			'dim': '3-10',     // (036)
			'aug': '3-12',     // (048)
	
			// Seventh chords (4-note sets)
			'maj7': '4-20',    // (0,4,7,11)
			'min7': '4-26',    // (0,3,7,10)
			'7': '4-27B',      // (0,4,7,10)
			'dim7': '4-28',    // (0,3,6,9)
			'm7b5': '4-27A',   // (0,3,6,10)
			'minMaj7': '4-19A', // (0,3,7,11)
			'aug7': '4-19B',    // (0,4,8,10)
			'augMaj7': '4-24',  // (0,4,8,11)
	
			// Extended sets can use more complex Forte numbers...
			'9': '5-27A',      // (0,2,4,7,10)
			'maj9': '5-27B',   // (0,2,4,7,11)
			'min9': '5-27A'    // (0,2,3,7,10)
		};
		const chordFullNames = {
			// Triads
			'maj': 'major triad',
			'min': 'minor triad',
			'dim': 'diminished triad', 
			'aug': 'augmented triad',
	
			// Seventh chords
			'maj7': 'major seventh',
			'min7': 'minor seventh',
			'7': 'dominant seventh',
			'dim7': 'diminished seventh',
			'm7b5': 'half-diminished seventh',
			'minMaj7': 'minor-major seventh',
			'aug7': 'augmented seventh',
			'augMaj7': 'augmented major seventh',
	
			// Sixth chords
			'6': 'major sixth',
			'm6': 'minor sixth',
	
			// Extended chords
			'9': 'dominant ninth',
			'maj9': 'major ninth',
			'min9': 'minor ninth',
			'11': 'dominant eleventh',
			'maj11': 'major eleventh',
			'min11': 'minor eleventh',
			'13': 'dominant thirteenth',
			'maj13': 'major thirteenth',
			'min13': 'minor thirteenth',
	
			// Suspended chords
			'sus2': 'suspended second',
			'sus4': 'suspended fourth',
			'7sus4': 'dominant seventh suspended fourth',
			'9sus4': 'dominant ninth suspended fourth',
	
			// Altered dominants
			'7b5': 'dominant seventh flat five',
			'7#5': 'dominant seventh sharp five',
			'7b9': 'dominant seventh flat nine',
			'7#9': 'dominant seventh sharp nine',
			'7#11': 'dominant seventh sharp eleven',
			'7b13': 'dominant seventh flat thirteen'
		};

		const chordQualities = {
            // Triads
            'maj': [0, 4, 7],
            'min': [0, 3, 7],
            'dim': [0, 3, 6],
            'aug': [0, 4, 8],
            
            // Seventh chords
            'maj7': [0, 4, 7, 11],
            'min7': [0, 3, 7, 10],
            '7': [0, 4, 7, 10],
            'dim7': [0, 3, 6, 9],
            'm7b5': [0, 3, 6, 10],
            'minMaj7': [0, 3, 7, 11],
            'aug7': [0, 4, 8, 10],
            'augMaj7': [0, 4, 8, 11],
            
            // Sixth chords
            '6': [0, 4, 7, 9],
            'm6': [0, 3, 7, 9],
            
            // Extended chords
            '9': [0, 4, 7, 10, 2],
            'maj9': [0, 4, 7, 11, 2],
            'min9': [0, 3, 7, 10, 2],
            '11': [0, 4, 7, 10, 2, 5],
            'maj11': [0, 4, 7, 11, 2, 5],
            'min11': [0, 3, 7, 10, 2, 5],
            '13': [0, 4, 7, 10, 2, 5, 9],
            'maj13': [0, 4, 7, 11, 2, 5, 9],
            'min13': [0, 3, 7, 10, 2, 5, 9],
            
            // Suspended chords
            'sus2': [0, 2, 7],
            'sus4': [0, 5, 7],
            '7sus4': [0, 5, 7, 10],
            '9sus4': [0, 5, 7, 10, 2],
            
            // Altered dominants
            '7b5': [0, 4, 6, 10],
            '7#5': [0, 4, 8, 10],
            '7b9': [0, 4, 7, 10, 1],
            '7#9': [0, 4, 7, 10, 3],
            '7#11': [0, 4, 7, 10, 2, 6],
            '7b13': [0, 4, 7, 10, 2, 8]
        };
        
		const compatibleScales = {
			// Major-based chords
			'maj': ['major', 'lydian', 'major bebop'],
			'maj7': ['major', 'lydian', 'major bebop'],
			'maj9': ['major', 'lydian'],
			'maj13': ['major', 'lydian'],
			'6': ['major', 'major pentatonic'],
	
			// Minor-based chords
			'min': ['minor', 'dorian', 'phrygian', 'melodic minor'],
			'min7': ['dorian', 'minor bebop', 'minor pentatonic', 'minor'],
			'min9': ['dorian', 'melodic minor'],
			'min11': ['dorian', 'minor'],
			'min13': ['dorian', 'melodic minor'],
			'm6': ['melodic minor', 'dorian'],
	
			// Dominant chords
			'7': ['mixolydian', 'lydian dominant', 'dominant bebop', 'blues'],
			'9': ['mixolydian', 'lydian dominant'],
			'13': ['mixolydian', 'lydian dominant'],
			'7sus4': ['mixolydian', 'suspended pentatonic'],
			'7alt': ['altered', 'diminished whole tone'],
	
			// Half-diminished and diminished
			'm7b5': ['locrian', 'locrian #2'],
			'dim7': ['diminished', 'whole-half diminished'],
	
			// Altered dominants
			'7b9': ['half-whole diminished', 'altered'],
			'7#9': ['altered', 'diminished whole tone'],
			'7#11': ['lydian dominant', 'altered'],
			'7b13': ['altered', 'phrygian dominant']
		};

		const avoidNotes = {
			// Major-based chords
			'maj7': ['4', '#4'],  // avoid perfect 4th and tritone
			'maj9': ['4'],        // avoid perfect 4th
			'maj13': ['4', '7'],  // avoid perfect 4th and minor 7th
	
			// Minor-based chords
			'min7': ['6', 'b6'],  // avoid both natural and flat 6th
			'min9': ['6'],        // avoid natural 6th
			'min11': ['13'],      // avoid 13th
	
			// Dominant chords
			'7': ['4', '11'],     // avoid perfect 4th/11th
			'9': ['4', '11'],     // avoid perfect 4th/11th
			'13': ['11'],         // avoid 11th
	
			// Half-diminished and diminished
			'm7b5': ['5'],        // avoid perfect 5th
			'dim7': ['maj7'],     // avoid major 7th
	
			// Altered dominants
			'7alt': ['5'],        // avoid perfect 5th
			'7b9': ['9'],         // avoid natural 9th
			'7#11': ['11'],       // avoid perfect 11th
			'7b13': ['13']        // avoid natural 13th
		};
		
		// Letter names in order (for calculating proper spelling distances)
		const letterNames = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
		
		// Function to find named inversions for a chord quality
		function findNamedInversions(quality, basePCS) {
			const inversions = [];
			const baseDecimal = parseInt(toBinaryPCS(basePCS), 2);
	
			// Try each other chord quality
			for (const [otherQuality, otherPCS] of Object.entries(chordQualities)) {
				if (quality === otherQuality) continue; // Skip self
				if (basePCS.length !== otherPCS.length) continue; // Must have same number of notes
		
				// Try each possible starting note of the other quality
				for (let i = 0; i < 12; i++) {
					const transposedPCS = transposePitchClassSet(otherPCS, i);
					const transposedDecimal = parseInt(toBinaryPCS(transposedPCS), 2);
			
					if (transposedDecimal === baseDecimal) {
						// Found a match - get the starting PC relative to the base chord
						const startingPC = transposedPCS[0];
						inversions.push({
							quality: otherQuality,
							rootPC: startingPC
						});
					}
				}
			}
	
			return inversions;
		}

		// Function to convert inversion data to notation
		function formatNamedInversion(inv) {
			return `(${inv.rootPC})${inv.quality}`;
		}

		// Initialize the named inversions dictionary
		const namedInversions = {};
		
		// Fixed order for chord components (in degree order)
		const degreeOrder = [
			0,   // root
			3,4, // thirds
			6,7, // fifths
			10,11, // sevenths
			1,2,   // ninths
			5,   // elevenths
			8,9    // thirteenths (or sixths)
		];


		// Build the named inversions for each chord quality
		Object.entries(chordQualities).forEach(([quality, pcs]) => {
			const invs = findNamedInversions(quality, pcs);
			if (invs.length > 0) {
				namedInversions[quality] = invs.map(formatNamedInversion);
			}
		});

        function parseChord(chordName) {
			if (!chordName) return null;
	
			// Try to match root and quality
			const match = chordName.match(/^([A-G][b#]?)(.*)$/);
			if (!match) return null;

			const [_, root, rawQuality] = match;
			let quality = rawQuality || 'maj'; // Default to major triad

			// Direct match with chord qualities
			if (chordQualities[quality]) {
				return { root, quality };
			}

			// Check aliases
			for (const [standardQuality, aliases] of Object.entries(chordAliases)) {
				if (aliases.includes(quality)) {
					return { root, quality: standardQuality };
				}
			}

			return null;
		}

        function orderByDegrees(pcSet, root = 0) {
			// Special case for sus4 chords
			if (pcSet.includes((root + 5) % 12) && pcSet.length === 5) {
				const susOrder = [0, 5, 7, 10, 1, 2, 3, 4, 6, 8, 9, 11];
				return [...pcSet].sort((a, b) => 
					susOrder.indexOf((a - root + 12) % 12) - 
					susOrder.indexOf((b - root + 12) % 12)
				);
			}
	
			// Normal ordering for other chords
			return [...pcSet].sort((a, b) => {
				const relA = (a - root + 12) % 12;
				const relB = (b - root + 12) % 12;
				const idxA = degreeOrder.indexOf(relA);
				const idxB = degreeOrder.indexOf(relB);
				return (idxA === -1 ? 999 : idxA) - (idxB === -1 ? 999 : idxB);
			});
		}

        function toBinaryPCS(pcSet) {
            let binary = new Array(12).fill(0);
            pcSet.forEach(pc => binary[pc] = 1);
            return binary.join('');
        }

        function transposePitchClassSet(pcSet, interval) {
			return pcSet.map(pc => (pc + interval) % 12);
		}
        
        function normalForm(pcSet) {
            let rotations = [];
            for (let i = 0; i < pcSet.length; i++) {
                let rotation = [...pcSet.slice(i), ...pcSet.slice(0, i)];
                rotation = rotation.map((pc, index) => 
                    index === 0 ? pc : (pc < rotation[0] ? pc + 12 : pc)
                );
                rotations.push(rotation);
            }
            
            // Sort rotations to find the most compact one
            rotations.sort((a, b) => {
                for (let i = 0; i < a.length - 1; i++) {
                    if (a[i + 1] - a[i] !== b[i + 1] - b[i]) {
                        return (a[i + 1] - a[i]) - (b[i + 1] - b[i]);
                    }
                }
                return 0;
            });

            // Return the most compact rotation, normalized to mod 12
            return rotations[0].map(pc => pc % 12);
        }
        
		function getAllTranspositionsWithBaseRef(pcs, root, baseDecimal) {
			const transpositions = {};
	
			// Get the base (C) version first
			const basePCS = getBasePCS(pcs, root);
			const orderedBasePCS = orderByDegreesFromRoot(basePCS, 0);
	
			// If no baseDecimal provided, calculate it from the base version
			if (baseDecimal === null) {
				baseDecimal = parseInt(toBinaryPCS(orderedBasePCS), 2);
			}
	
			// Now generate all transpositions starting from the base version
			for (let i = 0; i < 12; i++) {
				const currentRoot = noteToPCKeys[i];
				const transposedPCS = transposePitchClassSet(orderedBasePCS, i);
				const orderedTransposedPCS = orderByDegreesFromRoot(transposedPCS, i);
				const binary = toBinaryPCS(orderedTransposedPCS);
				const decimal = parseInt(binary, 2);
		
				transpositions[currentRoot] = {
					pcs: orderedTransposedPCS,
					binary,
					decimal
				};
			}
	
			return transpositions;
		}
		
		function getAllTranspositionsAndInversions(pcSet) {
			const transpositions = {};

			// For each possible transposition (0-11)
			for (let i = 0; i < 12; i++) {
				// Transpose the pitch class set
				const transposedSet = transposePitchClassSet(pcSet, i);

				// Calculate binary and decimal for the transposed set
				const binary = toBinaryPCS(transposedSet);
				const decimal = parseInt(binary, 2);

				// Generate all inversions for the transposed set
				const inversions = [];
				let rotatedSet = [...transposedSet];
				for (let j = 0; j < transposedSet.length; j++) {
					rotatedSet = [...rotatedSet.slice(1), rotatedSet[0]]; // Rotate
					const inversionBinary = toBinaryPCS(rotatedSet);
					const inversionDecimal = parseInt(inversionBinary, 2);
					inversions.push({ pcs: rotatedSet, binary: inversionBinary, decimal: inversionDecimal });
				}

				transpositions[noteToPCKeys[i]] = { pcs: transposedSet, binary, decimal, inversions };
			}

			return transpositions;
		}

        function getAllTranspositions(pcSet) {
			let transpositions = [];
	
			// For each possible transposition (0-11)
			for (let i = 0; i < 12; i++) {
				// Transpose the pitch class set
				const transposedSet = transposePitchClassSet(pcSet, i);
				// Convert to binary
				const binary = toBinaryPCS(transposedSet);
				// Convert to decimal
				const decimal = parseInt(binary, 2);
				// Add to array
				transpositions.push(decimal);
			}
	
			return transpositions;
		}

        // Add event listener for enter key on chord input
        document.getElementById('chordInput').addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                convertToPCS();
            }
        });

        function switchTab(tabName) {
            // Update button states
            document.querySelectorAll('.tab-button').forEach(button => {
                button.classList.remove('active');
            });
            event.target.classList.add('active');

            // Show/hide appropriate content
            document.getElementById('addChordTab').style.display = tabName === 'add' ? 'block' : 'none';
            document.getElementById('editChordTab').style.display = tabName === 'edit' ? 'block' : 'none';

            if (tabName === 'edit') {
                populateChordSelect();
            }
        }

        function populateChordSelect() {
            const select = document.getElementById('editQualitySelect');
            select.innerHTML = '<option value="">Select chord quality to edit</option>';
            
            Object.keys(chordQualities).sort().forEach(quality => {
                const option = document.createElement('option');
                option.value = quality;
                option.textContent = quality;
                select.appendChild(option);
            });
        }

		function loadChordQuality() {
			const quality = document.getElementById('editQualitySelect').value;
			if (!quality) return;

			const pcs = chordQualities[quality];
			const aliases = chordAliases[quality] || [];
			const fullName = chordFullNames[quality] || '';
			const forteNum = chordForteNumbers[quality] || '';
			const scales = compatibleScales[quality] || [];
			const avoid = avoidNotes[quality] || [];

			document.getElementById('editQualityPCS').value = pcs.join(',');
			document.getElementById('editQualityAliases').value = aliases.join(',');
			document.getElementById('editQualityFullName').value = fullName;
			document.getElementById('editQualityForte').value = forteNum;
			document.getElementById('editQualityScales').value = scales.join(',');
			document.getElementById('editQualityAvoid').value = avoid.join(',');
		}

		function enableResultEdit(quality) {
			document.getElementById('resultView').style.display = 'none';
			document.getElementById('resultEdit').style.display = 'block';
		}

		function saveResultEdit(quality) {
			const fullName = document.getElementById('editResultFullName').value.trim();
			const forteNum = document.getElementById('editResultForte').value.trim();
			const pcsInput = document.getElementById('editResultPCS').value.trim();
			const aliasesInput = document.getElementById('editResultAliases').value.trim();
			const scalesInput = document.getElementById('editResultScales').value.trim();
			const avoidInput = document.getElementById('editResultAvoid').value.trim();

			// Parse PCS input
			const pcs = pcsInput.split(',').map(n => parseInt(n.trim()));
			if (pcs.some(isNaN) || pcs.some(n => n < 0 || n > 11)) {
				alert('Invalid PCS. Please use numbers 0-11 separated by commas');
				return;
			}

			// Update dictionaries
			chordQualities[quality] = pcs;
	
			if (fullName) {
				chordFullNames[quality] = fullName;
			} else {
				delete chordFullNames[quality];
			}

			if (forteNum) {
				chordForteNumbers[quality] = forteNum;
			} else {
				delete chordForteNumbers[quality];
			}

			const aliases = aliasesInput ? aliasesInput.split(',').map(a => a.trim()) : [];
			if (aliases.length > 0) {
				chordAliases[quality] = aliases;
			} else {
				delete chordAliases[quality];
			}

			const scales = scalesInput ? scalesInput.split(',').map(s => s.trim()) : [];
			if (scales.length > 0) {
				compatibleScales[quality] = scales;
			} else {
				delete compatibleScales[quality];
			}

			const avoid = avoidInput ? avoidInput.split(',').map(n => n.trim()) : [];
			if (avoid.length > 0) {
				avoidNotes[quality] = avoid;
			} else {
				delete avoidNotes[quality];
			}

			// Update display
			filterChordTypes();
			convertToPCS(); // Refresh the result display
	
			document.getElementById('resultView').style.display = 'block';
			document.getElementById('resultEdit').style.display = 'none';
		}

		function updateChordQuality() {
			const quality = document.getElementById('editQualitySelect').value;
			if (!quality) {
				alert('Please select a chord quality to edit');
				return;
			}

			const pcsInput = document.getElementById('editQualityPCS').value.trim();
			const aliasesInput = document.getElementById('editQualityAliases').value.trim();
			const fullNameInput = document.getElementById('editQualityFullName').value.trim();
			const forteInput = document.getElementById('editQualityForte').value.trim();
			const scalesInput = document.getElementById('editQualityScales').value.trim();
			const avoidInput = document.getElementById('editQualityAvoid').value.trim();

			// Update dictionaries
			if (forteInput) {
				chordForteNumbers[quality] = forteInput;
			} else {
				delete chordForteNumbers[quality];
			}

			// Parse PCS input
			const pcs = pcsInput.split(',').map(n => parseInt(n.trim()));
			if (pcs.some(isNaN) || pcs.some(n => n < 0 || n > 11)) {
				alert('Invalid PCS. Please use numbers 0-11 separated by commas');
				return;
			}

			// Parse aliases
			const aliases = aliasesInput ? aliasesInput.split(',').map(a => a.trim()) : [];

			// Parse scales and avoid notes
			const scales = scalesInput ? scalesInput.split(',').map(s => s.trim()) : [];
			const avoid = avoidInput ? avoidInput.split(',').map(n => n.trim()) : [];

			// Update dictionaries
			chordQualities[quality] = pcs;
			if (aliases.length > 0) {
				chordAliases[quality] = aliases;
			} else {
				delete chordAliases[quality];
			}
			if (fullNameInput) {
				chordFullNames[quality] = fullNameInput;
			} else {
				delete chordFullNames[quality];
			}
			if (scales.length > 0) {
				compatibleScales[quality] = scales;
			} else {
				delete compatibleScales[quality];
			}
			if (avoid.length > 0) {
				avoidNotes[quality] = avoid;
			} else {
				delete avoidNotes[quality];
			}

			// Update display
			filterChordTypes();
			alert(`Chord quality "${quality}" has been updated`);
		}

		function addNewChordQuality() {
			const qualityName = document.getElementById('newQualityName').value.trim();
			const pcsInput = document.getElementById('newQualityPCS').value.trim();
			const aliasesInput = document.getElementById('newQualityAliases').value.trim();
			const fullNameInput = document.getElementById('newQualityFullName').value.trim();
			const forteInput = document.getElementById('newQualityForte').value.trim();
			const scalesInput = document.getElementById('newQualityScales').value.trim();
			const avoidInput = document.getElementById('newQualityAvoid').value.trim();

			if (!qualityName || !pcsInput) {
				alert('Please provide both quality name and PCS');
				return;
			}

			if (forteInput) {
				chordForteNumbers[qualityName] = forteInput;
			}

			// Parse PCS input
			const pcs = pcsInput.split(',').map(n => parseInt(n.trim()));
			if (pcs.some(isNaN) || pcs.some(n => n < 0 || n > 11)) {
				alert('Invalid PCS. Please use numbers 0-11 separated by commas');
				return;
			}

			// Parse aliases, scales and avoid notes
			const aliases = aliasesInput ? aliasesInput.split(',').map(a => a.trim()) : [];
			const scales = scalesInput ? scalesInput.split(',').map(s => s.trim()) : [];
			const avoid = avoidInput ? avoidInput.split(',').map(n => n.trim()) : [];

			// Add to dictionaries
			chordQualities[qualityName] = pcs;
			if (aliases.length > 0) {
				chordAliases[qualityName] = aliases;
			}
			if (fullNameInput) {
				chordFullNames[qualityName] = fullNameInput;
			}
			if (scales.length > 0) {
				compatibleScales[qualityName] = scales;
			}
			if (avoid.length > 0) {
				avoidNotes[qualityName] = avoid;
			}

			// Update display
			filterChordTypes();

			// Clear inputs
			document.getElementById('newQualityName').value = '';
			document.getElementById('newQualityPCS').value = '';
			document.getElementById('newQualityAliases').value = '';
			document.getElementById('newQualityFullName').value = '';
			document.getElementById('newQualityForte').value = '';
			document.getElementById('newQualityScales').value = '';
			document.getElementById('newQualityAvoid').value = '';
		}

		function exportChordDictionary() {
			const dictionary = {};

			Object.entries(chordQualities).forEach(([quality, pcs]) => {
				const orderedPCS = orderByDegrees(pcs);
				const binaryPCS = toBinaryPCS(pcs);
				const decimalPCS = parseInt(binaryPCS, 2);
				const transpositions = getAllTranspositions(pcs);
				const baseNotes = getChordNotes('C', orderedPCS);
		
				dictionary[quality] = {
					pcs: orderedPCS,
					notes: baseNotes,
					aliases: chordAliases[quality] || [],
					fullName: chordFullNames[quality] || quality,
					binary: binaryPCS,
					forteNumber: chordForteNumbers[quality] || '',
					decimal: decimalPCS,
					baseDecimal: decimalPCS,
					intervals: intervalToString(orderedPCS, quality),
					namedInversions: namedInversions[quality] || [],
					transpositions: Object.fromEntries(
						Object.entries(noteToPC).map(([note, pc]) => {
							const transposedPCS = transposePitchClassSet(orderedPCS, pc);
							const transposedNotes = getChordNotes(note, transposedPCS);
							return [note, {
								notes: transposedNotes,
								pcs: transposedPCS,
								decimal: parseInt(toBinaryPCS(transposedPCS), 2)
							}];
						})
					),
					compatibleScales: compatibleScales[quality] || [],
					avoidNotes: avoidNotes[quality] || []
				};
			});

			// Create and trigger download
			const dataStr = JSON.stringify(dictionary, null, 2);
			const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);

			const linkElement = document.createElement('a');
			linkElement.setAttribute('href', dataUri);
			linkElement.setAttribute('download', 'chord_dictionary.json');
			document.body.appendChild(linkElement);
			linkElement.click();
			document.body.removeChild(linkElement);
		}
	
        function orderByDegreesFromRoot(pcs, root) {
            // Normalize all PCs relative to the root
            let normalizedPcs = pcs.map(pc => (pc - root + 12) % 12);
            // Sort in ascending order
            normalizedPcs.sort((a, b) => a - b);
            // Shift back to original root
            return normalizedPcs.map(pc => (pc + root) % 12);
        }

		function findChordByTransposedPCS(pcs) {
			const normalizedPCS = normalForm(pcs);

			for (const [quality, baseIntervals] of Object.entries(chordQualities)) {
				for (let i = 0; i < 12; i++) {
					const transposedIntervals = transposePitchClassSet(baseIntervals, i);
					const transposedPCS = normalForm(transposedIntervals);
					if (JSON.stringify(normalizedPCS) === JSON.stringify(transposedPCS)) {
						const rootPC = (pcs[0] - transposedIntervals[0] + 12) % 12;
						const root = Object.keys(noteToPC).find(key => noteToPC[key] === rootPC);
						return { quality, root: root || 'Unknown', baseQuality: quality };
					}
				}
			}
			return null;
		}

		function decimalToPCS(decimal) {
			const binary = decimal.toString(2).padStart(12, '0');
			return binary
				.split('')
				.map((b, i) => (b === '1' ? i : null))
				.filter(i => i !== null);
		}

		function convertToPCS() {
			const input = document.getElementById('chordInput').value.trim();
			const resultDiv = document.getElementById('result');
	
			const result = parseChordInput(input);
			if (result) {
				const { pcs, quality, root, baseDecimal } = result;
				displayDetailedResult(pcs, quality, root, baseDecimal);
			} else {
				resultDiv.innerHTML = 'Invalid input. Please enter a valid chord, PCS, or decimal notation.';
			}
		}
		
		function findChordByDecimal(decimal) {
			const searchPCS = decimalToPCS(decimal);
	
			// Try each quality and transposition
			for (const [quality, basePCS] of Object.entries(chordQualities)) {
				const baseDecimal = parseInt(toBinaryPCS(basePCS), 2);
		
				// Try each possible transposition
				for (let i = 0; i < 12; i++) {
					const transposedPCS = transposePitchClassSet(basePCS, i);
					const transposedDecimal = parseInt(toBinaryPCS(transposedPCS), 2);
			
					if (transposedDecimal === decimal) {
						// Find root note based on transposition
						const rootNote = noteToPCKeys[i];
						return {
							quality,
							root: rootNote,
							baseDecimal,
							pcs: orderByDegreesFromRoot(transposedPCS, i)
						};
					}
				}
			}
			return null;
		}

		function findChordByPCS(inputPCS) {
			// First note is our root
			const rootPC = inputPCS[0];

			// Get the interval pattern from input
			const inputPattern = inputPCS.map(pc => (pc - rootPC + 12) % 12);

			// Try each chord quality
			for (const [quality, basePCS] of Object.entries(chordQualities)) {
				// Skip if lengths don't match
				if (basePCS.length !== inputPCS.length) continue;

				// Compare patterns
				const basePattern = basePCS.map(pc => (pc - 0 + 12) % 12);
		
				if (JSON.stringify(inputPattern) === JSON.stringify(basePattern)) {
					const root = Object.entries(noteToPC).find(([_, pc]) => pc === rootPC)?.[0] || 'C';
					return {
						quality,
						root,
						baseDecimal: parseInt(toBinaryPCS(basePCS), 2),
						pcs: inputPCS
					};
				}
			}
			return null;
		}
		
		// Function to add named inversions to detailed result display
		function displayDetailedResult(pcs, quality = 'Custom PCS', root = 'C', baseDecimal = null) {
			const resultDiv = document.getElementById('result');
			const rootPC = noteToPC[root];

			// Get the base chord quality's PCS and transpose it
			const basePCS = chordQualities[quality];
			const transposedPCS = basePCS ? transposePitchClassSet(basePCS, rootPC) : pcs;
	
			// Order PCS by degrees from the root
			const orderedPCS = orderByDegrees(transposedPCS, rootPC);
	
			// Calculate display values
			const binaryPCS = toBinaryPCS(orderedPCS);
			const decimalPCS = parseInt(binaryPCS, 2);
			const showEditButton = quality !== 'Custom PCS';

			// Calculate base decimal (what it would be if root was C)
			if (baseDecimal === null) {
				const basePCS = transposePitchClassSet(orderedPCS, (12 - rootPC) % 12);
				baseDecimal = parseInt(toBinaryPCS(basePCS), 2);
			}

			// Get intervals relative to root
			const intervals = orderedPCS.map(pc => (pc - rootPC + 12) % 12);
			const notes = getChordNotes(root, intervals, quality);

			// Get inversions information - only show actual inversions, not self-reference
			const inversions = findRelatedChords(transposedPCS, quality)
				.filter(inv => inv.quality !== quality || inv.root !== root);
	
			const inversionsHtml = inversions.length > 0 ? `
				<div class="inversions-section">
					<h4>Named Inversions:</h4>
					<ul>
						${inversions.map(inv => `
							<li>${inv.root}${inv.quality} [${inv.notes.join(', ')}]</li>
						`).join('')}
					</ul>
				</div>
			` : '';

			// Generate transpositions with inversions
			let transpositionOutput = '';
			Object.entries(noteToPC).forEach(([note, pc]) => {
				const transPCS = transposePitchClassSet(basePCS || pcs, pc);
				const orderedTransPCS = orderByDegrees(transPCS, pc);
				const transIntervals = orderedTransPCS.map(tpc => (tpc - pc + 12) % 12);
				const transNotes = getChordNotes(note, transIntervals, quality);
				const binary = toBinaryPCS(orderedTransPCS);
				const decimal = parseInt(binary, 2);
		
				transpositionOutput += `
					<p><b>${note}:</b> 
					   Notes: [${transNotes.join(', ')}],
					   PCS: [${orderedTransPCS.join(', ')}], 
					   Binary: ${binary}, 
					   Decimal: ${decimal}</p>
				`;
			});

			resultDiv.innerHTML = `
				<div class="result-header">
					<h3>Result for ${root}${quality}</h3>
					${showEditButton ? `
						<button onclick="editChord('${quality}')" class="edit-button">
							Edit Quality
						</button>
					` : ''}
				</div>
				<div class="result-content">
					<p>Full Name: ${chordFullNames[quality] || quality}</p>
					<p>Forte Number: ${chordForteNumbers[quality] || 'N/A'}</p>
					<p>Root: ${root} (${rootPC})</p>
					<p>Notes: [${notes.join(', ')}]</p>
					<p>Intervals: ${intervalToString(intervals, quality)}</p>
					<p>Pitch Class Set (from root): [${orderedPCS.join(', ')}]</p>
					<p>Binary: <span class="binary-format">${binaryPCS}</span></p>
					<p>Decimal: ${decimalPCS}</p>
					<p>Base Decimal (C): ${baseDecimal}</p>
					<p>Compatible Scales: ${compatibleScales[quality]?.join(', ') || 'N/A'}</p>
					<p>Avoid Notes: ${avoidNotes[quality]?.join(', ') || 'None'}</p>
					${inversionsHtml}
					<p>Transpositions:</p>
					<div>${transpositionOutput}</div>
				</div>
			`;
		}

		function editChord(quality) {
			// Switch to the "Edit Existing" tab
			switchTab('edit');

			// Set the dropdown to the selected chord quality
			const select = document.getElementById('editQualitySelect');
			select.value = quality;

			// Populate the fields for the selected quality
			loadChordQuality();
		}

		// Chord categories for filtering
        const chordCategories = {
            'triads': ['maj', 'min', 'dim', 'aug'],
            'seventh': ['maj7', 'min7', '7', 'dim7', 'm7b5', 'minMaj7', 'aug7', 'augMaj7'],
            'sixth': ['6', 'm6'],
            'extended': ['9', 'maj9', 'min9', '11', 'maj11', 'min11', '13', 'maj13', 'min13'],
            'suspended': ['sus2', 'sus4', '7sus4', '9sus4'],
            'altered': ['7b5', '7#5', '7b9', '7#9', '7#11', '7b13']
        };

		function intervalToString(intervals, quality = '') {
			// Make sure root comes first
			const withoutRoot = intervals.filter(i => i !== 0);
			const orderedInts = [0, ...orderIntervals(withoutRoot)];
	
			return orderedInts
				.map(interval => getIntervalQuality(interval, quality))
				.join(', ');
		}
        
        function filterChordTypes() {
			const category = document.getElementById('chordCategory').value;
			const chordList = document.getElementById('chordList');
			chordList.innerHTML = '';

			let chordsToShow;
			if (category === 'all') {
				chordsToShow = Object.entries(chordQualities);
			} else {
				chordsToShow = Object.entries(chordQualities)
					.filter(([quality]) => chordCategories[category].includes(quality));
			}

			chordsToShow.forEach(([quality, intervals]) => {
				const orderedPCS = orderByDegreesFromRoot(intervals, 0);
				const binaryPCS = toBinaryPCS(intervals);
				const decimalPCS = parseInt(binaryPCS, 2);
				const notes = getChordNotes('C', orderedPCS);
				const aliases = chordAliases[quality] ? `(${chordAliases[quality].join(', ')})` : '';
				const inversions = getInversionsList(intervals, quality);

				const chordItem = document.createElement('div');
				chordItem.className = 'chord-item';
				chordItem.innerHTML = `
					<div class="chord-name">C${quality} ${aliases}</div>
					<div class="chord-fullname">${chordFullNames[quality] || quality}</div>
					<div class="chord-forte">Forte: ${chordForteNumbers[quality] || 'N/A'}</div>
					<div class="chord-notes">Notes: [${notes.join(', ')}]</div>
					<div class="chord-intervals">Intervals: ${intervalToString(intervals, quality)}</div>
					<div class="chord-scales">Scales: ${compatibleScales[quality]?.join(', ') || 'N/A'}</div>
					<div class="chord-avoid">Avoid: ${avoidNotes[quality]?.join(', ') || 'None'}</div>
					${inversions}
					<div class="chord-pcs">PCS: [${orderedPCS.join(', ')}]</div>
					<div class="chord-binary">Binary: <span class="binary-format">${binaryPCS}</span></div>
					<div class="chord-decimal">Decimal: ${decimalPCS}</div>
				`;
				chordList.appendChild(chordItem);
			});
		}

        
        function importChordDictionary() {
			document.getElementById('jsonFileInput').click();
		}

		function handleFileUpload(event) {
			const file = event.target.files[0];
			if (!file) return;

			const reader = new FileReader();
			reader.onload = function(e) {
				try {
					const data = JSON.parse(e.target.result);

					// Validate data format
					if (typeof data !== 'object') {
						throw new Error('Invalid JSON format');
					}

					// Populate chord qualities and all related data
					Object.entries(data).forEach(([quality, info]) => {
						// Required fields
						if (info.pcs && Array.isArray(info.pcs)) {
							chordQualities[quality] = info.pcs;
						}
				
						// Optional fields
						if (info.aliases && Array.isArray(info.aliases)) {
							chordAliases[quality] = info.aliases;
						}
				
						if (info.fullName) {
							chordFullNames[quality] = info.fullName;
						}
				
						if (info.forteNumber) {
							chordForteNumbers[quality] = info.forteNumber;
						}
				
						if (info.compatibleScales && Array.isArray(info.compatibleScales)) {
							compatibleScales[quality] = info.compatibleScales;
						}
				
						if (info.avoidNotes && Array.isArray(info.avoidNotes)) {
							avoidNotes[quality] = info.avoidNotes;
						}
				
						if (info.namedInversions && Array.isArray(info.namedInversions)) {
							namedInversions[quality] = info.namedInversions;
						}
					});

					// Update the UI
					filterChordTypes();
					alert('Chord dictionary imported successfully!');
				} catch (error) {
					alert('Failed to import JSON: ' + error.message);
				}
			};

			reader.readAsText(file);
		}
		
		// Helper function to normalize PC array to start from 0
		function normalizeToZero(pcSet) {
			if (!pcSet.length) return [];
			const minPC = Math.min(...pcSet);
			return pcSet.map(pc => (pc - minPC + 12) % 12);
		}

		// Helper to check if two PC sets are equivalent under transposition
		function areEquivalentPCS(pcs1, pcs2) {
			if (pcs1.length !== pcs2.length) return false;
	
			// Try all possible rotations of pcs1
			for (let i = 0; i < pcs1.length; i++) {
				const rotated = [...pcs1.slice(i), ...pcs1.slice(0, i)];
				// Try all possible transpositions of the rotation
				for (let j = 0; j < 12; j++) {
					const transposed = transposePitchClassSet(rotated, j);
					if (JSON.stringify(transposed.sort()) === JSON.stringify([...pcs2].sort())) {
						return true;
					}
				}
			}
			return false;
		}


		function parseChordInput(input) {
			// Validate dependencies first
			if (!input || !chordFullNames || !chordQualities || !noteToPC) {
				console.log("Missing dependencies:", { chordFullNames, chordQualities, noteToPC });
				return null;
			}

			input = input.trim();

			// Try full name parsing first (e.g., "C minor triad")
			if (input.includes(' ')) {
				const rootMatch = input.match(/^([A-G][b#]?)\s/);
				console.log('Input:', input);
				console.log('Root match:', rootMatch);
				
				if (rootMatch) {
					const root = rootMatch[1];
					const namePart = input.slice(rootMatch[0].length).trim().toLowerCase();
					console.log('Parsing full name:', { 
						root, 
						namePart,
						inputLength: input.length,
						namePartLength: namePart.length 
					});
					console.log('Available full names:', JSON.stringify(chordFullNames, null, 2));
			
					// Search for matching quality
					for (const [quality, fullName] of Object.entries(chordFullNames)) {
						const lowerFullName = fullName.toLowerCase();
						console.log('Comparing:', { 
							quality, 
							fullName: lowerFullName, 
							namePart,
							fullNameLength: lowerFullName.length,
							namePartLength: namePart.length,
							areEqual: lowerFullName === namePart,
							stringComparison: JSON.stringify({lowerFullName, namePart})
						});
						if (lowerFullName === namePart) {
							console.log('Found match:', quality);
							const basePCS = chordQualities[quality];
							if (basePCS) {
								const rootPC = noteToPC[root];
								return {
									quality,
									root,
									baseDecimal: parseInt(toBinaryPCS(basePCS), 2),
									pcs: transposePitchClassSet(basePCS, rootPC)
								};
							}
						}
					}
					console.log('No match found');
				}
			}

			// Try PCS notation
			const pcsMatch = input.match(/\[([\d,\s]+)\]/);
			if (pcsMatch) {
				const pcs = pcsMatch[1].split(',').map(n => parseInt(n.trim()));
				if (!pcs.some(isNaN)) {  // Ensure all numbers parsed correctly
					return findChordByPCS(pcs);
				}
			}

			// Try chord symbol
			const parsed = parseChord(input);
			if (parsed) {
				const { root, quality } = parsed;
				const basePCS = chordQualities[quality];
				if (basePCS) {
					const rootPC = noteToPC[root];
					return {
						quality,
						root,
						baseDecimal: parseInt(toBinaryPCS(basePCS), 2),
						pcs: transposePitchClassSet(basePCS, rootPC)
					};
				}
			}

			// Try decimal notation
			if (/^\d+$/.test(input)) {
				return findChordByDecimal(parseInt(input, 10));
			}

			return null;
		}



		// Gets the base (C) version of any PCS
		function getBasePCS(pcs, root) {
			const rootPC = noteToPC[root] || 0;
			// Transpose back to C
			return transposePitchClassSet(pcs, (12 - rootPC) % 12);
		}

		// Helper function to get intervals from a root note
		function getIntervalPattern(pcs, root) {
			// Convert PCS to intervals from the root, maintaining order
			return pcs.map(pc => (pc - root + 12) % 12);
		}

		// Function to parse PCS from string format "[0, 4, 8]" -> [0, 4, 8]
		function parsePCS(pcsString) {
			const match = pcsString.match(/\[([\d,\s]+)\]/);
			if (!match) return null;
			return match[1].split(',').map(n => parseInt(n.trim()));
		}

		// Function to parse aliases from string format "{alias1, alias2}" -> ["alias1", "alias2"]
		function parseAliases(aliasString) {
			const match = aliasString.match(/\{([^}]+)\}/);
			if (!match) return [];
			return match[1].split(',').map(a => a.trim());
		}

		// Function to generate a quality name from PCS if none is provided
		function generateQualityName(pcs) {
			return `custom_${pcs.join('_')}`;
		}
		
		// Helper to find existing chord quality by PCS
		function findExistingQualityByPCS(pcs) {
			const searchDecimal = parseInt(toBinaryPCS(pcs), 2);
			for (const [quality, qualityPCS] of Object.entries(chordQualities)) {
				if (qualityPCS.length === pcs.length) {
					const qualityDecimal = parseInt(toBinaryPCS(qualityPCS), 2);
					if (qualityDecimal === searchDecimal) {
						return quality;
					}
				}
			}
			return null;
		}
		
		// Helper to merge arrays without duplicates
		function mergeUnique(arr1 = [], arr2 = []) {
			return [...new Set([...arr1, ...arr2])];
		}

		
		// Helper to determine if an interval is added/suspended
		function isSpecialInterval(interval, quality) {
			const isSus = quality.includes('sus') && (interval === 2 || interval === 5);
			const isAdd = interval === 2 || interval === 4 || interval === 6;
			return isSus || (isAdd && quality.includes('add' + interval));
		}

		function intervalToString(intervals, quality = '') {
			const orderedInts = orderIntervals(intervals);
			return orderedInts.map(interval => getIntervalQuality(interval, quality)).join(', ');
		}

		// New function to get note names
		function getChordNotes(root, intervals, quality = '') {
			// Root letter and standard letter sequence
			const rootLetter = root.charAt(0);
			const letterNames = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
	
			return intervals.map(interval => {
				if (interval === 0) return root;
		
				// Get target letter based on standard intervals
				let steps;
				switch (interval) {
					case 4:  steps = 2; break;  // major third = 2 letters up
					case 7:  steps = 4; break;  // perfect fifth = 4 letters up
					case 11: steps = 6; break;  // major seventh = 6 letters up
					case 2:  steps = 1; break;  // major second = 1 letter up
					case 9:  steps = 5; break;  // major sixth = 5 letters up
					default: steps = Math.floor(interval * 2/3);
				}
		
				// Get target letter
				const rootIndex = letterNames.indexOf(rootLetter);
				const targetLetter = letterNames[(rootIndex + steps) % 7];
		
				// Calculate required pitch adjustment
				const naturalPC = noteToPC[targetLetter];
				const desiredPC = (noteToPC[root] + interval) % 12;
				const adjustment = (desiredPC - naturalPC + 12) % 12;

				// Special cases for sharp keys
				if ((root === 'C#' || root === 'F#') && quality.indexOf('min') === -1) {
					if (interval === 4) return targetLetter + '♯';  // E# instead of F
					if (interval === 11) return targetLetter + '♯'; // B# instead of C
				}
		
				// Add appropriate accidental
				switch (adjustment) {
					case 0:  return targetLetter;
					case 1:  return root.includes('b') ? targetLetter + '♭' : targetLetter + '♯';
					case 2:  return targetLetter + '♯';
					case 10: return targetLetter + '♭';
					case 11: return targetLetter + '♭';
					default: return targetLetter;
				}
			});
		}

		// Function to get note names for a transposition
		function getTranspositionNotes(rootNote, intervals) {
			const notes = getChordNotes(rootNote, intervals);
			return notes.join(', ');
		}
				
		function getIntervalQuality(interval, quality = '') {
			const degreeMap = {
				0: 'R',
				1: '♭9',
				2: '9',
				3: '♭3',
				4: '3',
				5: '11',
				6: '♭5',
				7: '5',
				8: '♭13',
				9: '13',  // Changed from '6'
				10: '♭7',
				11: '7'
			};

			// Special case handling
			if (interval === 9 && !quality?.includes('13')) {
				return '6';
			}
	
			// Handle suspensions
			if (quality?.includes('sus')) {
				if (interval === 2) return '2';
				if (interval === 5) return '4';
			}

			return degreeMap[interval];
		}

		// Update the priority map in the orderByDegrees function
		function orderIntervals(intervals, quality = '') {
			// First, normalize intervals relative to the root (0)
			const normalized = intervals.map(interval => interval % 12);

			// Priority map for interval ordering - updated for sus chords
			const priority = {
				0: 0,    // Root
				5: 1,    // Fourth (for sus4)
				2: 1,    // Second (for sus2)
				3: 1,    // Minor third
				4: 1,    // Major third
				7: 2,    // Fifth
				10: 3,   // Minor seventh
				11: 3,   // Major seventh
				9: 3,    // Sixth/thirteenth
				1: 4,    // Minor ninth
				2: 4,    // Major ninth (when not sus)
				5: 5,    // Eleventh (when not sus)
				8: 6,    // Minor thirteenth
				6: 7     // Others (altered fifths etc.)
			};

			// Special handling for sus chords
			if (quality?.includes('sus')) {
				// Prioritize sus intervals
				if (quality.includes('sus4')) {
					priority[5] = 1;  // Fourth takes third position
					priority[3] = 8;  // Deprioritize thirds
					priority[4] = 8;
				} else if (quality.includes('sus2')) {
					priority[2] = 1;  // Second takes third position
					priority[3] = 8;  // Deprioritize thirds
					priority[4] = 8;
				}
			}

			return normalized.sort((a, b) => {
				const aValue = priority[a] ?? 8;
				const bValue = priority[b] ?? 8;
				return aValue === bValue ? a - b : aValue - bValue;
			});
		}

		
		// Helper function to determine enharmonic spelling based on chord context
		function getEnharmonicSpelling(pc, root, quality) {
			const flatQualities = ['min', 'dim', 'm7b5', 'minMaj7'];
			const useFlats = flatQualities.some(q => quality.includes(q));
	
			// Map of preferred spellings
			const spellings = {
				1: useFlats ? 'D♭' : 'C♯',
				3: useFlats ? 'E♭' : 'D♯',
				6: useFlats ? 'G♭' : 'F♯',
				8: useFlats ? 'A♭' : 'G♯',
				10: useFlats ? 'B♭' : 'A♯'
			};
	
			return spellings[pc] || noteToPCKeys[pc];
		}

		// Helper to get the relative intervals from a root note
		function getRelativeIntervals(pcs, root) {
			return pcs.map(pc => (pc - root + 12) % 12);
		}

		
		// Get the letter index (0-6) for a note name
		function getLetterIndex(noteName) {
			return letterNames.indexOf(noteName[0]);
		}

		// Get the next X letters from a starting letter (wrapping around)
		function getLetterOffset(startLetter, offset) {
			const startIndex = getLetterIndex(startLetter);
			return letterNames[(startIndex + offset + 7) % 7];
		}

		// Function to find related chords that share the same pitch class set
		function findRelatedChords(pcs, quality = '') {
			// Get the decimal representation of this PCS
			const decimal = parseInt(toBinaryPCS(pcs), 2);
			const results = [];
	
			// Check each chord quality
			Object.entries(chordQualities).forEach(([otherQuality, otherPCS]) => {
				// Skip if different number of notes
				if (otherPCS.length !== pcs.length) return;
				// Skip self-reference with same root
				if (otherQuality === quality && JSON.stringify(pcs) === JSON.stringify(otherPCS)) return;
		
				// Check each possible root position
				for (let i = 0; i < 12; i++) {
					const transposed = transposePitchClassSet(otherPCS, i);
					const transposedDecimal = parseInt(toBinaryPCS(transposed), 2);
			
					if (transposedDecimal === decimal) {
						// Calculate the correct notes based on the root position
						const rootNote = noteToPCKeys[i];
						const intervals = transposed.map(pc => (pc - i + 12) % 12);
						const notes = getChordNotes(rootNote, intervals, otherQuality);
				
						results.push({
							quality: otherQuality,
							root: rootNote,
							rootPC: i,
							pcs: transposed,
							notes: notes
						});
					}
				}
			});
	
			return results;
		}

		// Function to format inversion display
		function formatInversion(inv) {
			return `${inv.root}${inv.quality}`;
		}

		// Function to find and format all related chords for a given chord
		function getInversionsList(pcs, quality) {
			const related = findRelatedChords(pcs, quality);
			if (related.length === 0) return '';
	
			return `
				<div class="chord-inversions">
					Named Inversions: ${related.map(inv => `${inv.root}${inv.quality}`).join(', ')}
				</div>
			`;
		}

		
		// Function to update the named inversions dictionary
		function updateNamedInversions() {
			Object.entries(chordQualities).forEach(([quality, pcs]) => {
				const related = findRelatedChords(pcs, quality);
				if (related.length > 0) {
					namedInversions[quality] = related.map(inv => `(${inv.rootPC})${inv.quality}`);
				}
			});
		}

		// Function to get named inversions display for a specific chord
		function getNamedInversionsDisplay(root, quality, pcs) {
			const transposed = transposePitchClassSet(pcs, noteToPC[root]);
			const related = findRelatedChords(transposed, quality);
	
			if (related.length === 0) return '';
	
			let html = '<div class="named-inversions">\n';
			html += '<h4>Named Inversions:</h4>\n';
			html += '<ul>\n';
	
			related.forEach(inv => {
				html += `<li>${inv.root}${inv.quality} [${inv.notes.join(', ')}]</li>\n`;
			});
	
			html += '</ul>\n</div>';
			return html;
		}
        
        // Function to automatically load the chord dictionary
        async function loadChordDictionary() {
            try {
                const response = await fetch('chord_dictionary.json');
                if (!response.ok) {
                    console.warn('Could not load chord_dictionary.json, using default dictionary');
                    return;
                }
                const data = await response.json();
                
                // Validate data format
                if (typeof data !== 'object') {
                    console.warn('Invalid JSON format in chord_dictionary.json, using default dictionary');
                    return;
                }

                // Populate chord qualities and all related data
                Object.entries(data).forEach(([quality, info]) => {
                    // Required fields
                    if (info.pcs && Array.isArray(info.pcs)) {
                        chordQualities[quality] = info.pcs;
                    }
            
                    // Optional fields
                    if (info.aliases && Array.isArray(info.aliases)) {
                        chordAliases[quality] = info.aliases;
                    }
            
                    if (info.fullName) {
                        chordFullNames[quality] = info.fullName;
                    }
            
                    if (info.forteNumber) {
                        chordForteNumbers[quality] = info.forteNumber;
                    }
            
                    if (info.compatibleScales && Array.isArray(info.compatibleScales)) {
                        compatibleScales[quality] = info.compatibleScales;
                    }
            
                    if (info.avoidNotes && Array.isArray(info.avoidNotes)) {
                        avoidNotes[quality] = info.avoidNotes;
                    }
            
                    if (info.namedInversions && Array.isArray(info.namedInversions)) {
                        namedInversions[quality] = info.namedInversions;
                    }
                });

                console.log('Chord dictionary loaded successfully');
            } catch (error) {
                console.warn('Error loading chord_dictionary.json, using default dictionary:', error);
            }
        }

        // Test Framework - Defined before any usage
        window.TestSuite = {
            tests: [],
            results: {
                passed: 0,
                failed: 0,
                total: 0
            },

            test: function(name, fn) {
                console.log(`Adding test: ${name}`);
                this.tests.push({ name, fn });
            },

            assertEqual: function(actual, expected, message) {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(`${message}\nExpected: ${JSON.stringify(expected)}\nActual: ${JSON.stringify(actual)}`);
                }
            },

            runTests: async function() {
                console.log('Running tests...');
                const resultDiv = document.createElement('div');
                resultDiv.id = 'testResults';
                resultDiv.style.padding = '20px';
                resultDiv.style.margin = '20px';
                resultDiv.style.border = '1px solid #ccc';
                document.body.appendChild(resultDiv);

                this.results = { passed: 0, failed: 0, total: 0 };

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.results.passed++;
                        resultDiv.innerHTML += `<p style="color: green">✓ ${test.name}</p>`;
                    } catch (error) {
                        this.results.failed++;
                        resultDiv.innerHTML += `
                            <p style="color: red">✗ ${test.name}</p>
                            <pre style="background: #f8f8f8; padding: 10px; margin: 5px 0;">${error.message}</pre>
                        `;
                    }
                    this.results.total++;
                }

                resultDiv.innerHTML += `
                    <h3>Test Results</h3>
                    <p>Total: ${this.results.total}</p>
                    <p style="color: green">Passed: ${this.results.passed}</p>
                    <p style="color: red">Failed: ${this.results.failed}</p>
                `;
            }
        };

        window.runChordTests = async function() {
            console.log('Starting chord tests...');
            
            // Basic Chord Parsing Tests
            TestSuite.test('Parse major triad', () => {
                const result = parseChord('Cmaj');
                TestSuite.assertEqual(result, { root: 'C', quality: 'maj' }, 'Failed to parse Cmaj');
            });

            TestSuite.test('Parse minor seventh', () => {
                const result = parseChord('Dm7');
                TestSuite.assertEqual(result, { root: 'D', quality: 'min7' }, 'Failed to parse Dm7');
            });

            // Full Name Parsing Tests
            TestSuite.test('Parse full name - minor triad', () => {
                console.log('Testing full name parsing for minor triad...');
                const result = parseChordInput('C minor triad');
                console.log('Result:', result);
                TestSuite.assertEqual(result.quality, 'min', 'Failed to parse minor triad from full name');
            });

            TestSuite.test('Parse full name - major seventh', () => {
                console.log('Testing full name parsing for major seventh...');
                const result = parseChordInput('D major seventh');
                console.log('Result:', result);
                TestSuite.assertEqual(result.quality, 'maj7', 'Failed to parse major seventh from full name');
            });

            // PCS Notation Tests
            TestSuite.test('Parse PCS - major triad', () => {
                const result = parseChordInput('[0, 4, 7]');
                TestSuite.assertEqual(result.quality, 'maj', 'Failed to parse major triad from PCS');
            });

            TestSuite.test('Parse PCS - major sixth', () => {
                const result = parseChordInput('[0, 4, 7, 9]');
                TestSuite.assertEqual(result.quality, '6', 'Failed to parse major sixth from PCS');
            });

            // Decimal Notation Tests
            TestSuite.test('Parse decimal - C#maj7', () => {
                const result = parseChordInput('3144');  // Should be C#maj7
                TestSuite.assertEqual(
                    { root: result.root, quality: result.quality }, 
                    { root: 'C#', quality: 'maj7' }, 
                    'Failed to parse C#maj7 from decimal 3144'
                );
            });

            // Degree Ordering Tests
            TestSuite.test('Degree ordering - min13', () => {
                const pcs = chordQualities['min13'];
                const ordered = orderByDegrees(pcs);
                TestSuite.assertEqual(
                    ordered, 
                    [0, 3, 7, 10, 2, 5, 9], 
                    'Failed to order min13 correctly'
                );
            });

            TestSuite.test('Degree ordering - 7b9sus4', () => {
                const pcs = chordQualities['7b9sus4'] || [0, 5, 7, 10, 1];
                const ordered = orderByDegrees(pcs);
                TestSuite.assertEqual(
                    ordered, 
                    [0, 5, 7, 10, 1], 
                    'Failed to order 7b9sus4 correctly'
                );
            });

            // Transposition Tests
            TestSuite.test('Transposition - Bbmaj7', () => {
                const result = parseChordInput('Bbmaj7');
                const expectedPCS = [10, 2, 5, 9];  // Properly ordered Bbmaj7
                TestSuite.assertEqual(
                    result.pcs, 
                    expectedPCS, 
                    'Failed to get correct PCS for Bbmaj7'
                );
            });

            // Run the tests
            await TestSuite.runTests();
        };
        const TestSuite = {
            tests: [],
            results: {
                passed: 0,
                failed: 0,
                total: 0
            },

            test: function(name, fn) {
                this.tests.push({ name, fn });
            },

            assertEqual: function(actual, expected, message) {
                if (JSON.stringify(actual) !== JSON.stringify(expected)) {
                    throw new Error(`${message}\nExpected: ${JSON.stringify(expected)}\nActual: ${JSON.stringify(actual)}`);
                }
            },

            runTests: async function() {
                const resultDiv = document.createElement('div');
                resultDiv.id = 'testResults';
                resultDiv.style.padding = '20px';
                resultDiv.style.margin = '20px';
                resultDiv.style.border = '1px solid #ccc';
                document.body.appendChild(resultDiv);

                this.results = { passed: 0, failed: 0, total: 0 };

                for (const test of this.tests) {
                    try {
                        await test.fn();
                        this.results.passed++;
                        resultDiv.innerHTML += `<p style="color: green">✓ ${test.name}</p>`;
                    } catch (error) {
                        this.results.failed++;
                        resultDiv.innerHTML += `
                            <p style="color: red">✗ ${test.name}</p>
                            <pre style="background: #f8f8f8; padding: 10px; margin: 5px 0;">${error.message}</pre>
                        `;
                    }
                    this.results.total++;
                }

                resultDiv.innerHTML += `
                    <h3>Test Results</h3>
                    <p>Total: ${this.results.total}</p>
                    <p style="color: green">Passed: ${this.results.passed}</p>
                    <p style="color: red">Failed: ${this.results.failed}</p>
                `;
            }
        };

        // Chord Dictionary Tests
        const ChordDictionaryTests = {
            init: async function() {
                // Basic Chord Parsing Tests
                TestSuite.test('Parse major triad', () => {
                    const result = parseChord('Cmaj');
                    TestSuite.assertEqual(result, { root: 'C', quality: 'maj' }, 'Failed to parse Cmaj');
                });

                TestSuite.test('Parse minor seventh', () => {
                    const result = parseChord('Dm7');
                    TestSuite.assertEqual(result, { root: 'D', quality: 'min7' }, 'Failed to parse Dm7');
                });

                // Chord Symbol Aliases Tests
                TestSuite.test('Parse major seventh alias (Δ)', () => {
                    const result = parseChord('CΔ');
                    TestSuite.assertEqual(result, { root: 'C', quality: 'maj7' }, 'Failed to parse CΔ');
                });

                TestSuite.test('Parse diminished alias (°)', () => {
                    const result = parseChord('C°');
                    TestSuite.assertEqual(result, { root: 'C', quality: 'dim' }, 'Failed to parse C°');
                });

                // PCS Input Tests
                TestSuite.test('Parse PCS notation', () => {
                    const result = findChordByPCS([0, 4, 7]);
                    TestSuite.assertEqual(result.quality, 'maj', 'Failed to identify major triad from PCS');
                });

                TestSuite.test('Parse altered PCS notation', () => {
                    const result = findChordByPCS([0, 4, 6, 10]);
                    TestSuite.assertEqual(result.quality, '7b5', 'Failed to identify 7b5 from PCS');
                });

                // Decimal Notation Tests
                TestSuite.test('Parse decimal notation', () => {
                    const result = findChordByDecimal(2192); // Major triad
                    TestSuite.assertEqual(result.quality, 'maj', 'Failed to identify major triad from decimal');
                });

                // Full Name Tests
                TestSuite.test('Parse full name', () => {
                    const result = parseChordInput('C minor seventh');
                    TestSuite.assertEqual(result.quality, 'min7', 'Failed to parse full name');
                });

                // Transposition Tests
                TestSuite.test('Test major triad transposition', () => {
                    const pcs = chordQualities['maj'];
                    const transposed = transposePitchClassSet(pcs, 2); // Up a whole step
                    TestSuite.assertEqual(transposed, [2, 6, 9], 'Failed to transpose major triad');
                });

                // Run all tests
                await TestSuite.runTests();
            }
        };

        // Add button to run tests
        function addTestButton() {
            const button = document.createElement('button');
            button.innerHTML = 'Run z7 Tests';
            button.style.margin = '20px';
            button.onclick = function() {
                runChordTests();
            };
            const container = document.querySelector('.container');
            if (container) {
                container.insertBefore(button, container.firstChild);
            }
        }

        // Initialize chord dictionary and tests on load
        window.addEventListener('load', async function() {
            console.log('Window loaded');
            await loadChordDictionary();
            filterChordTypes();
//             addTestButton();
        });        
    </script>
</body>
</html>