<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Dictionary</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        select {
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
        }
        .content p {
            margin: 8px 0;
        }
        .monospace {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <input type="text" id="chordInput" placeholder="Type a chord (e.g., Bb7, F#m7)" style="padding: 8px; font-size: 16px; border: 1px solid #ccc; border-radius: 4px;">
        <select id="rootSelect">
            <option value="C">C</option>
            <option value="Câ™¯">Câ™¯</option>
            <option value="Dâ™­">Dâ™­</option>
            <option value="D">D</option>
            <option value="Dâ™¯">Dâ™¯</option>
            <option value="Eâ™­">Eâ™­</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="Fâ™¯">Fâ™¯</option>
            <option value="Gâ™­">Gâ™­</option>
            <option value="G">G</option>
            <option value="Gâ™¯">Gâ™¯</option>
            <option value="Aâ™­">Aâ™­</option>
            <option value="A">A</option>
            <option value="Aâ™¯">Aâ™¯</option>
            <option value="Bâ™­">Bâ™­</option>
            <option value="B">B</option>
        </select>
        <select id="qualitySelect">
            <option value="">Select quality...</option>
        </select>
    </div>

    <!-- Change the result div to use flexbox -->
	<div id="result" class="card" style="display: none">
		<div class="title" id="chordTitle"></div>
		<div style="display: flex; gap: 20px; align-items: start;">
			<div class="content" style="flex: 1;">
				<p id="fullName">Full name:</p>
				<p id="aliases"></p>
				<p id="intervals"></p>
				<p id="notes"></p>
				<p id="altSpellings"></p>
				<p id="namedInversions"></p>
				<div class="monospace">
					<p id="pcs"></p>
					<p id="forteNumber"></p>
					<p id="binary"></p>
					<p id="decimal"></p>
				</div>
			</div>
			<div id="chordCircle" style="flex: 1;"></div>
		</div>
		<div class="controls mb-4">
			<button id="toggleCircle" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300">
				Toggle Circle View
			</button>
			<button id="toggleNotesDisplay" class="px-4 py-2 bg-gray-100 hover:bg-gray-200 rounded border border-gray-300">
				Show All Notes
			</button>
		</div>
	</div>



	<!-- Replace the existing checkbox-container divs with this 
	<div class="controls-section" style="margin: 20px 0;">
		<h3>Export Options</h3>
		<div class="checkbox-container">
			<h4>Include Fields:</h4>
			<label><input type="checkbox" class="export-field" value="intervals" checked> Intervals</label>
			<label><input type="checkbox" class="export-field" value="fullName" checked> Full Name</label>
			<label><input type="checkbox" class="export-field" value="aliases" checked> Aliases</label>
			<label><input type="checkbox" class="export-field" value="forteNumber" checked> Forte Number</label>
			<label><input type="checkbox" class="export-field" value="namedInversions" checked> Named Inversions</label>
			<label><input type="checkbox" class="export-field" value="avoidNotes" checked> Avoid Notes</label>
			<label><input type="checkbox" class="export-field" value="compatibleScales" checked> Compatible Scales</label>
			<label><input type="checkbox" class="export-field" value="transpositions" id="transpositions-checkbox" checked> Transpositions</label>
		</div>
	
		<div id="transposition-options" class="checkbox-container" style="margin-left: 20px; display: block;">
			<h4>Transposition Fields:</h4>
			<label><input type="checkbox" class="transposition-field" value="notes" checked> Notes</label>
			<label><input type="checkbox" class="transposition-field" value="pcs" checked> Pitch Classes</label>
			<label><input type="checkbox" class="transposition-field" value="binary" checked> Binary</label>
			<label><input type="checkbox" class="transposition-field" value="decimal" checked> Decimal</label>
			<label><input type="checkbox" class="transposition-field" value="namedInversions" checked> Specific Inversions</label>
		</div>
	</div>

	<button onclick="exportChordDictionary()">Export JSON</button>
-->
	<style>
		.controls-section {
			background: #f5f5f5;
			padding: 15px;
			border-radius: 8px;
			margin-bottom: 20px;
		}
	
		.checkbox-container {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 5px;
		}
	
		.checkbox-container label {
			display: flex;
			align-items: center;
			gap: 5px;
		}
	
		h4 {
			width: 100%;
			margin: 5px 0;
		}
	</style>

    <script>
        // Interval definitions for both pitch class and letter steps
        const intervalMap = {
            'R':    { letters: 0, semitones: 0 },
            'â™­2':   { letters: 1, semitones: 1 },
            '2':    { letters: 1, semitones: 2 },
            'â™­3':   { letters: 2, semitones: 3 },
            '3':    { letters: 2, semitones: 4 },
            '4':    { letters: 3, semitones: 5 },
            'â™¯4':   { letters: 3, semitones: 6 },
            'â™­5':   { letters: 4, semitones: 6 },
            '5':    { letters: 4, semitones: 7 },
            'â™¯5':   { letters: 4, semitones: 8 },
            'â™­6':   { letters: 5, semitones: 8 },
            '6':    { letters: 5, semitones: 9 },
            'ğ„«7':   { letters: 6, semitones: 9 },
            'â™­7':   { letters: 6, semitones: 10 },
            '7':    { letters: 6, semitones: 11 },
            'â™­9':   { letters: 1, semitones: 1 },
            '9':    { letters: 1, semitones: 2 },
            'â™¯9':   { letters: 1, semitones: 3 },
            '11':   { letters: 3, semitones: 5 },
            'â™¯11':  { letters: 3, semitones: 6 },
            'â™­13':  { letters: 5, semitones: 8 },
            '13':   { letters: 5, semitones: 9 }
        };
        
		// Add this in the script section, before any function that uses it
		const intervalToPosition = {
			'R': 0, 
			'â™­2': 1, '2': 2, 'â™¯2': 3,
			'â™­3': 3, '3': 4, 
			'4': 5, 'â™¯4': 6,
			'â™­5': 6, '5': 7, 'â™¯5': 8,
			'â™­6': 8, '6': 9,
			'ğ„«7': 9, 'â™­7': 10, '7': 11,
			'â™­9': 1, '9': 2, 'â™¯9': 3,
			'11': 5, 'â™¯11': 6,
			'â™­13': 8, '13': 9
		};




        const qualitySelect = document.getElementById('qualitySelect');
        const rootSelect = document.getElementById('rootSelect');
        const resultDiv = document.getElementById('result');
        
        let chordData = {};

        function getPC(note) {
            const letterPCs = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
            const baseLetter = note[0];
            const basePC = letterPCs[baseLetter];
            
            if (note.includes('ğ„«')) return (basePC - 2 + 12) % 12;
            if (note.includes('ğ„ª')) return (basePC + 2) % 12;
            if (note.includes('â™­â™­')) return (basePC - 2 + 12) % 12;
            if (note.includes('â™¯')) return (basePC + 1) % 12;
            if (note.includes('â™­')) return (basePC - 1 + 12) % 12;
            return basePC;
        }

        function buildNoteFromInterval(root, interval) {
            const letters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const letterPCs = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
            
            // Get root letter index
            const rootIndex = letters.indexOf(root[0]);
            
            // Calculate target letter using interval's letter steps
            const targetLetterIndex = (rootIndex + interval.letters) % 7;
            const targetLetter = letters[targetLetterIndex];
            
            // Calculate target PC using root's PC plus interval's semitones
            const rootPC = getPC(root);
            const targetPC = (rootPC + interval.semitones) % 12;
            
            // Calculate needed alteration
            const naturalPC = letterPCs[targetLetter];
            const alteration = (targetPC - naturalPC + 12) % 12;
            
            // Return the note with appropriate accidental
            if (alteration === 0) return targetLetter;
            if (alteration === 1) return targetLetter + 'â™¯';
            if (alteration === 2) return targetLetter + 'ğ„ª';
            if (alteration === 10) return targetLetter + 'ğ„«';
            if (alteration === 11) return targetLetter + 'â™­';
            
            console.warn('Unexpected alteration:', alteration);
            return targetLetter;
        }

        function transposeChord(root, quality, chordData) {
            if (!chordData[quality]) return null;
            const chord = chordData[quality];

            // If root is C, use the exact notes from JSON
            if (root === 'C') {
                return {
                    ...chord,
                    notes: chord.notes,
                    pcs: chord.pcs,
                    binary: chord.binary,
                    decimal: chord.decimal
                };
            }

            // Build each note from intervals
            const transposedNotes = chord.intervals.map(intervalName => {
                const interval = intervalMap[intervalName];
                return buildNoteFromInterval(root, interval);
            });

            // Calculate pitch classes
            const pcs = transposedNotes.map(note => getPC(note));

            // Generate binary from PCs
            const binary = Array(12).fill('0');
            pcs.forEach(pc => binary[pc] = '1');
            const binaryStr = binary.join('');

            return {
                ...chord,
                notes: transposedNotes,
                pcs,
                binary: binaryStr,
                decimal: parseInt(binaryStr, 2)
            };
        }

        // Load chord dictionary
        fetch('chord_dictionary.json')
            .then(response => response.json())
            .then(data => {
                chordData = data;
                // Populate quality select
                Object.keys(data).sort().forEach(quality => {
                    const option = document.createElement('option');
                    option.value = quality;
                    option.textContent = quality;
                    qualitySelect.appendChild(option);
                });
            })
            .catch(error => console.error('Error loading chord data:', error));

		// Then modify the updateChordDisplay function
		function updateChordDisplay() {
			const root = rootSelect.value;
			const quality = qualitySelect.value;

			if (!quality) {
				resultDiv.style.display = 'none';
				return;
			}

			const chord = transposeChord(root, quality, chordData);
			if (!chord) return;

			// Update chord circle
			const chordCircleContainer = document.getElementById('chordCircle');
			chordCircleContainer.innerHTML = createChordCircle(root, chord.intervals, chord);

			// Get inversions and alternative spellings
			const roots = ['C', 'Câ™¯', 'Dâ™­', 'D', 'Dâ™¯', 'Eâ™­', 'E', 'F', 'Fâ™¯', 'Gâ™­', 'G', 'Gâ™¯', 'Aâ™­', 'A', 'Aâ™¯', 'Bâ™­', 'B'];
			const inversions = findSpecificInversions(root, quality, roots, chordData);
	
			// Basic chord info
			document.getElementById('chordTitle').textContent = `${root}${chordData[quality].displayName || quality}`;
			document.getElementById('fullName').textContent = `Full Name: ${chord.fullName}`;
			document.getElementById('forteNumber').textContent = `Forte Number: ${chord.forteNumber}`;
			document.getElementById('intervals').textContent = `Intervals: [${chord.intervals.join(', ')}]`;
			document.getElementById('notes').textContent = `Notes: [${chord.notes.join(', ')}]`;
			document.getElementById('pcs').textContent = `Pitch Classes: [${chord.pcs.join(', ')}]`;
			document.getElementById('aliases').textContent = `Aliases: [${chord.aliases.join(', ')}]`;
	
			// Alternative spellings and inversions
			if (inversions.length > 0) {
				const altSpellings = inversions
					.filter(inv => inv.interval === 0)
					.map(spelling => `${spelling.chord} [${spelling.notes.join(', ')}]`);

				const trueInversions = inversions
					.filter(inv => inv.interval !== 0)
					.map(inv => `${inv.chord} [${inv.notes.join(', ')}]`);

				if (altSpellings.length > 0) {
					document.getElementById('altSpellings').textContent = 
						`Alternative Spellings: ${altSpellings.join('; ')}`;
					document.getElementById('altSpellings').style.display = 'block';
				} else {
					document.getElementById('altSpellings').style.display = 'none';
				}

				if (trueInversions.length > 0) {
					const invElement = document.getElementById('namedInversions');
					invElement.innerHTML = `Named Inversions:<br>${trueInversions.join('<br>')}`;
					invElement.style.display = 'block';
				} else {
					document.getElementById('namedInversions').style.display = 'none';
				}
			} else {
				document.getElementById('altSpellings').style.display = 'none';
				document.getElementById('namedInversions').style.display = 'none';
			}

			document.getElementById('binary').textContent = `Binary: ${chord.binary}`;
			document.getElementById('decimal').textContent = `Decimal: ${chord.decimal}`;

			resultDiv.style.display = 'block';
		}



        rootSelect.addEventListener('change', updateChordDisplay);
        qualitySelect.addEventListener('change', updateChordDisplay);

        function findNamedInversions() {
            let decimalMap = {};
            let namedInversionsMap = {};

            const roots = ['C', 'Câ™¯', 'D', 'Dâ™¯', 'E', 'F', 'Fâ™¯', 'G', 'Gâ™¯', 'A', 'Aâ™¯', 'B'];
            const semitoneMap = {
                "C": 0, "Câ™¯": 1, "D": 2, "Dâ™¯": 3, "E": 4, "F": 5, "Fâ™¯": 6, 
                "G": 7, "Gâ™¯": 8, "A": 9, "Aâ™¯": 10, "B": 11
            };

            Object.keys(chordData).forEach(quality => {
                roots.forEach(root => {
                    let transposed = transposeChord(root, quality, chordData);
                    if (!transposed) return;

                    let decimal = transposed.decimal;
                    let chordIdentifier = root + " " + quality;

                    if (!decimalMap[decimal]) {
                        decimalMap[decimal] = [];
                    }
                    decimalMap[decimal].push({ root: root, quality: quality });
                });
            });

            Object.keys(decimalMap).forEach(decimal => {
                if (decimalMap[decimal].length > 1) {
                    let chords = decimalMap[decimal];

                    chords.forEach(chord => {
                        let chordQuality = chord.quality;
                        if (!namedInversionsMap[chordQuality]) {
                            namedInversionsMap[chordQuality] = [];
                        }

                        chords.forEach(otherChord => {
                            if (otherChord.quality !== chord.quality || otherChord.root !== chord.root) {
                                let interval = (semitoneMap[otherChord.root] - semitoneMap[chord.root] + 12) % 12;
                                let inversionEntry = `(${interval})${otherChord.quality}`;
                                if (!namedInversionsMap[chordQuality].includes(inversionEntry)) {
                                    namedInversionsMap[chordQuality].push(inversionEntry);
                                }
                            }
                        });
                    });
                }
            });

            return namedInversionsMap;
        }
        
        // Helper function to compare sets
		function setsEqual(set1, set2) {
			if (set1.size !== set2.size) return false;
			for (const item of set1) {
				if (!set2.has(item)) return false;
			}
			return true;
		}
		
		// Find specific inversions with full details
		function findSpecificInversions(root, quality, roots, chordData) {
			const inversions = [];
			const currentChord = transposeChord(root, quality, chordData);
			if (!currentChord) return inversions;

			const currentPCs = new Set(currentChord.pcs);
	
			roots.forEach(otherRoot => {
				Object.keys(chordData).forEach(otherQuality => {
					if (root === otherRoot && quality === otherQuality) return;
			
					const otherChord = transposeChord(otherRoot, otherQuality, chordData);
					if (!otherChord) return;

					const otherPCs = new Set(otherChord.pcs);
			
					// Check if pitch class sets are equal
					if (setsEqual(currentPCs, otherPCs)) {
						// Calculate interval between roots
						const interval = (getPC(otherRoot) - getPC(root) + 12) % 12;
				
						inversions.push({
							interval,
							chord: `${otherRoot}${otherQuality}`,
							intervals: otherChord.intervals,
							notes: otherChord.notes,
							pcs: otherChord.notes.map(note => getPC(note))
						});
					}
				});
			});

			// Sort by interval
			return inversions.sort((a, b) => a.interval - b.interval);
		}

		
		// Format inversion for display
		function formatInversion(inv) {
			return `(${inv.interval}), ${inv.chord}, [${inv.intervals.join(', ')}], [${inv.notes.join(', ')}], [${inv.pcs.join(', ')}]`;
		}

		// Update export function
		function exportChordDictionary() {
			const selectedFields = Array.from(document.querySelectorAll('.export-field:checked'))
				.map(checkbox => checkbox.value);

			const roots = ['C', 'Câ™¯', 'Dâ™­', 'D', 'Dâ™¯', 'Eâ™­', 'E', 'F', 'Fâ™¯', 'Gâ™­', 'G', 'Gâ™¯', 'Aâ™­', 'A', 'Aâ™¯', 'Bâ™­', 'B'];
			let exportData = {};

			Object.keys(chordData).forEach(quality => {
				let chord = chordData[quality];
				let exportedChord = {};

				selectedFields.forEach(field => {
					if (field !== "transpositions") {
						exportedChord[field] = chord[field];
					}
				});

				if (selectedFields.includes("transpositions")) {
					exportedChord.transpositions = {};
					roots.forEach(root => {
						let transposed = transposeChord(root, quality, chordData);
						if (!transposed) return;
				
						exportedChord.transpositions[root] = {
							intervals: transposed.intervals,
							notes: transposed.notes,
							pcs: transposed.pcs.sort((a, b) => a - b)
						};

						// Add specific inversions and alternative spellings if they exist
						const specificInversions = findSpecificInversions(root, quality, roots, chordData);
						if (specificInversions.length > 0) {
							const altSpellings = specificInversions
								.filter(inv => inv.interval === 0)
								.map(alt => ({
									chord: alt.chord,
									notes: alt.notes
								}));
					
							const trueInversions = specificInversions.filter(inv => inv.interval !== 0);
					
							if (altSpellings.length > 0) {
								exportedChord.transpositions[root].alternativeSpellings = altSpellings;
							}
					
							if (trueInversions.length > 0) {
								exportedChord.transpositions[root].namedInversions = trueInversions;
							}
						}
					});
				}

				exportData[quality] = exportedChord;
			});

			const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
			const url = URL.createObjectURL(jsonBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "chord_dictionary_export.json";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}
		
		// Define createChordCircle before it's used
		function createChordCircle(root, intervals, chord) {
			// Circle of fifths order with gradual contrast that wraps around
			const fifthsColors = {
				'F':  '#00FF00', 
				'C':  '#FFFF00', 
				'G':  '#FFC000', 
				'D':  '#FF8000', 
				'A':  '#FF0000', 
				'E':  '#FF00FF', 
				'B':  '#8000FF', 
				'Fâ™¯': '#0000FF', 
				'Câ™¯': '#0080FF', 
				'Gâ™¯': '#00C0FF', 
				'Dâ™¯': '#00FFFF', 
				'Aâ™¯': '#40FFC0', 
				'Bâ™­': '#40FFC0', 
				'Eâ™­': '#00FFFF', 
				'Aâ™­': '#00C0FF', 
				'Dâ™­': '#0080FF', 
				'Gâ™­': '#0000FF'  
			};
// 			const fifthsColors = {
// 				'F':  '#4575B4', // Base blue
// 				'C':  '#74ADD1', // Less contrasting blue
// 				'G':  '#ABD9E9', // Light blue
// 				'D':  '#E0F3F8', // Very light blue
// 				'A':  '#FEE090', // Light orange
// 				'E':  '#FDAE61', // Orange
// 				'B':  '#F46D43', // Red-orange (maximum contrast)
// 				'Fâ™¯': '#FDAE61', // Orange (mirror of E)
// 				'Câ™¯': '#FEE090', // Light orange (mirror of A)
// 				'Gâ™¯': '#E0F3F8', // Very light blue (mirror of D)
// 				'Dâ™¯': '#ABD9E9', // Light blue (mirror of G)
// 				'Aâ™¯': '#74ADD1', // Less contrasting blue (mirror of C)
// 				'Bâ™­': '#74ADD1', // Same as Aâ™¯
// 				'Eâ™­': '#ABD9E9', // Same as Dâ™¯
// 				'Aâ™­': '#E0F3F8', // Same as Gâ™¯
// 				'Dâ™­': '#FEE090', // Same as Câ™¯
// 				'Gâ™­': '#FDAE61'  // Same as Fâ™¯
// 			};

			// Map for pitch class colors (including rare spellings and double accidentals)
			const pitchClassColors = {
				'Bâ™¯': fifthsColors['C'],   // PC 0
				'Eâ™¯': fifthsColors['F'],   // PC 5
				'Fâ™­': fifthsColors['E'],   // PC 4
				'Câ™­': fifthsColors['B'],   // PC 11
				// Double accidentals
				'Cğ„ª': fifthsColors['D'],   // PC 2
				'Fğ„ª': fifthsColors['G'],   // PC 7
				'Gğ„ª': fifthsColors['A'],   // PC 9
				'Dğ„ª': fifthsColors['E'],   // PC 4
				'Ağ„ª': fifthsColors['B'],   // PC 11
				'Eğ„ª': fifthsColors['Fâ™¯'],  // PC 6
				'Bğ„ª': fifthsColors['Câ™¯'],  // PC 1
				'Cğ„«': fifthsColors['Bâ™­'],  // PC 10
				'Fğ„«': fifthsColors['Eâ™­'],  // PC 3
				'Gğ„«': fifthsColors['F'],   // PC 5
				'Dğ„«': fifthsColors['C'],   // PC 0
				'Ağ„«': fifthsColors['G'],   // PC 7
				'Eğ„«': fifthsColors['D'],   // PC 2
				'Bğ„«': fifthsColors['A']    // PC 9
			};

			const radius = 100;
			const centerX = 150;
			const centerY = 150;
			const noteRadius = 12;

			// Get the notes in the chord for highlighting early
			const chordNotes = new Set(chord.notes);
			console.log('Chord notes:', Array.from(chordNotes));

			// All possible spellings at each chromatic position
			const allSpellings = [
				['C'],                // 0 (add Bâ™¯ only if in chord)
				['Câ™¯', 'Dâ™­'],        // 1
				['D'],                // 2
				['Dâ™¯', 'Eâ™­'],        // 3
				['E'],                // 4 (add Fâ™­ only if in chord)
				['F'],                // 5 (add Eâ™¯ only if in chord)
				['Fâ™¯', 'Gâ™­'],        // 6
				['G'],                // 7
				['Gâ™¯', 'Aâ™­'],        // 8
				['A'],                // 9
				['Aâ™¯', 'Bâ™­'],        // 10
				['B']                 // 11 (add Câ™­ only if in chord)
			];

			// Add rare spellings if they're in the chord (including double accidentals)
			if (chordNotes.has('Bâ™¯')) allSpellings[0].push('Bâ™¯');
			if (chordNotes.has('Fâ™­')) allSpellings[4].push('Fâ™­');
			if (chordNotes.has('Eâ™¯')) allSpellings[5].push('Eâ™¯');
			if (chordNotes.has('Câ™­')) allSpellings[11].push('Câ™­');
	
			// Double sharp spellings
			if (chordNotes.has('Cğ„ª')) allSpellings[2].push('Cğ„ª');
			if (chordNotes.has('Fğ„ª')) allSpellings[7].push('Fğ„ª');
			if (chordNotes.has('Gğ„ª')) allSpellings[9].push('Gğ„ª');
			if (chordNotes.has('Dğ„ª')) allSpellings[4].push('Dğ„ª');
			if (chordNotes.has('Ağ„ª')) allSpellings[11].push('Ağ„ª');
			if (chordNotes.has('Eğ„ª')) allSpellings[6].push('Eğ„ª');
			if (chordNotes.has('Bğ„ª')) allSpellings[1].push('Bğ„ª');
	
			// Double flat spellings
			if (chordNotes.has('Cğ„«')) allSpellings[10].push('Cğ„«');
			if (chordNotes.has('Fğ„«')) allSpellings[3].push('Fğ„«');
			if (chordNotes.has('Gğ„«')) allSpellings[5].push('Gğ„«');
			if (chordNotes.has('Dğ„«')) allSpellings[0].push('Dğ„«');
			if (chordNotes.has('Ağ„«')) allSpellings[7].push('Ağ„«');
			if (chordNotes.has('Eğ„«')) allSpellings[2].push('Eğ„«');
			if (chordNotes.has('Bğ„«')) allSpellings[9].push('Bğ„«');

			// Helper function to determine if a color is dark (needs white text)
			function isColorDark(hexcolor) {
				const r = parseInt(hexcolor.slice(1,3), 16);
				const g = parseInt(hexcolor.slice(3,5), 16);
				const b = parseInt(hexcolor.slice(5,7), 16);
				// Calculate perceived brightness using weighted RGB values
				const brightness = (r * 299 + g * 587 + b * 114) / 1000;
				return brightness < 128;
			}

			function getRootPosition(note) {
				const positions = {
					'C': 0, 'Câ™¯': 1, 'Dâ™­': 1, 'D': 2, 'Dâ™¯': 3, 'Eâ™­': 3,
					'E': 4, 'F': 5, 'Fâ™¯': 6, 'Gâ™­': 6, 'G': 7, 'Gâ™¯': 8,
					'Aâ™­': 8, 'A': 9, 'Aâ™¯': 10, 'Bâ™­': 10, 'B': 11, 'Câ™­': 11
				};
				return positions[note] || 0;
			}

			function getNotePosition(hour, radiusOffset = 0) {
				const angle = (hour * 30 - 90) * (Math.PI / 180); // Start at C (top)
				return {
					x: centerX + (radius + radiusOffset) * Math.cos(angle),
					y: centerY + (radius + radiusOffset) * Math.sin(angle)
				};
			}

			// Root position in chromatic circle
			const rootPos = getRootPosition(root);

			// Calculate radius range for interval nodes
			const minRadius = -90; // Inner limit, close to center
			const maxRadius = -10; // Outer limit, close to chromatic circle
	
			// Map interval types to relative radial positions (0-1)
			const intervalRadialPosition = {
				'R': 0,      // Root at innermost position
				'2': 0.1, 'â™­2': 0.05, 'â™¯2': 0.15,
				'3': 0.2, 'â™­3': 0.15,
				'4': 0.25, 'â™¯4': 0.3,
				'5': 0.35, 'â™­5': 0.3, 'â™¯5': 0.4,
				'6': 0.45, 'â™­6': 0.4,
				'7': 0.55, 'â™­7': 0.5, 'ğ„«7': 0.45,
				'9': 0.65, 'â™­9': 0.6, 'â™¯9': 0.7,
				'11': 0.8, 'â™¯11': 0.85,
				'13': 0.95, 'â™­13': 0.9
			};

			// Calculate interval node positions and mapping to actual notes
			const intervalNodes = intervals.map((interval, index) => {
				// Get chromatic position relative to root
				let position = (intervalToPosition[interval] + rootPos) % 12;
		
				// Calculate radius based on interval type
				const radialPos = intervalRadialPosition[interval] || 0;
				const radiusOffset = minRadius + (maxRadius - minRadius) * radialPos;
		
				return {
					...getNotePosition(position, radiusOffset),
					interval,
					note: chord.notes[index]  // Get the actual note for this interval
				};
			});

			// Generate SVG content
			let svg = `
				<svg viewBox="0 0 300 300" style="width: 100%; max-width: 400px; margin: 0 auto;">
					<!-- Reference lines -->
					${allSpellings.map((_, i) => {
						const angle = (i * 30 - 90) * (Math.PI / 180);
						const x2 = centerX + radius * Math.cos(angle);
						const y2 = centerY + radius * Math.sin(angle);
						return `
							<line 
								x1="${centerX}" 
								y1="${centerY}" 
								x2="${x2}" 
								y2="${y2}"
								stroke="#eee" 
								stroke-width="1" 
								stroke-dasharray="2,2"
							/>
						`;
					}).join('')}
			
					<!-- Main circle -->
					<circle 
						cx="${centerX}" 
						cy="${centerY}" 
						r="${radius}"
						fill="none" 
						stroke="#ddd" 
						stroke-width="1"
					/>
			`;

			// Add all possible note spellings
			allSpellings.forEach((spellings, i) => {
				spellings.forEach((note, spellIndex) => {
					const isChordTone = chordNotes.has(note);
					console.log(`Checking note: ${note}, is chord tone: ${isChordTone}`);
			
					// Skip if we're only showing chord tones and this isn't one
					if (window.showOnlyChordTones && !isChordTone) {
						return;
					}

					const labelOffset = 20;
					// Offset position slightly if there are multiple spellings
					const xOffset = spellings.length > 1 ? (spellIndex === 0 ? -8 : 8) : 0;
					const basePos = getNotePosition(i, labelOffset);
					const labelPos = {
						x: basePos.x + xOffset,
						y: basePos.y
					};
			
					const noteColor = fifthsColors[note] || pitchClassColors[note] || '#666';
					const textColor = isColorDark(noteColor) ? '#fff' : '#000';
			
					svg += `
						<g>
							<circle
								cx="${labelPos.x}"
								cy="${labelPos.y}"
								r="${noteRadius}"
								fill="${noteColor}"
								stroke="${isChordTone ? '#000' : 'none'}"
								stroke-width="${isChordTone ? '3' : '0'}"
								opacity="0.8"
							/>
							<text
								x="${labelPos.x}"
								y="${labelPos.y}"
								text-anchor="middle"
								alignment-baseline="middle"
								font-size="12"
								fill="${textColor}"
							>${note}</text>
						</g>
					`;
				});
			});

			// Add lines connecting interval nodes
			for (let i = 0; i < intervalNodes.length - 1; i++) {
				const current = intervalNodes[i];
				const next = intervalNodes[i + 1];
				svg += `
					<line
						x1="${current.x}"
						y1="${current.y}"
						x2="${next.x}"
						y2="${next.y}"
						stroke="#666"
						stroke-width="2"
					/>
				`;
			}

			// Add interval nodes
			intervalNodes.forEach((node, i) => {
				const noteColor = fifthsColors[node.note] || pitchClassColors[node.note] || '#666';
				const textColor = isColorDark(noteColor) ? '#fff' : '#000';
		
				svg += `
					<g>
						<circle
							cx="${node.x}"
							cy="${node.y}"
							r="${noteRadius}"
							fill="${noteColor}"
							stroke="#333"
							stroke-width="2"
						/>
						<text
							x="${node.x}"
							y="${node.y}"
							text-anchor="middle"
							alignment-baseline="middle"
							font-size="12"
							fill="${textColor}"
							font-weight="bold"
						>${node.interval}</text>
					</g>
				`;
			});

			svg += '</svg>';
			return svg;
		}


		document.getElementById('chordInput').addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				const input = this.value.trim();
				if (!input) return;
		
				// Parse chord symbol BEFORE normalizing accidentals
				const match = input.match(/^([A-G][b#]?)(.*)$/);
				if (!match) return;
		
				const [_, rootRaw, qualityRaw] = match;
		
				// Now normalize accidentals for the root only
				const root = rootRaw.replace(/b/g, 'â™­').replace(/#/g, 'â™¯');
		
				// Keep quality as is for dictionary lookup
				const quality = qualityRaw;
		
				// Find the main quality - first check if it's a direct key
				let mainQuality = quality;
		
				if (!chordData[mainQuality]) {
					// If not a direct key, look through aliases
					for (let key in chordData) {
						if (chordData[key].aliases && 
							chordData[key].aliases.includes(quality)) {
							mainQuality = key;
							break;
						}
					}
				}
		
				// Update select elements if values exist
				if (rootSelect.querySelector(`option[value="${root}"]`) && 
					qualitySelect.querySelector(`option[value="${mainQuality}"]`)) {
					rootSelect.value = root;
					qualitySelect.value = mainQuality;
					updateChordDisplay();
				}
			}
		});


		document.getElementById('toggleCircle').addEventListener('click', function() {
			const circleDiv = document.getElementById('chordCircle');
			if (circleDiv.style.display === 'none') {
				circleDiv.style.display = 'block';
				// If circle is currently empty but chord is selected, update it
				if (!circleDiv.innerHTML && qualitySelect.value) {
					updateChordDisplay();
				}
			} else {
				circleDiv.style.display = 'none';
			}
		});


		// Add this global variable
		window.showOnlyChordTones = true;

		document.getElementById('toggleNotesDisplay').addEventListener('click', function() {
			window.showOnlyChordTones = !window.showOnlyChordTones;
			this.textContent = window.showOnlyChordTones ? 'Show All Notes' : 'Show Chord Tones Only';
			// Update the display if the circle is visible
			if (document.getElementById('chordCircle').style.display !== 'none') {
				updateChordDisplay();
			}
		});




		

				

// 		document.getElementById('transpositions-checkbox').addEventListener('change', function() {
// 			document.getElementById('transposition-options').style.display = this.checked ? 'block' : 'none';
// 		});

</script>

</body>
</html>