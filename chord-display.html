<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Dictionary</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        select {
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
        }
        .content p {
            margin: 8px 0;
        }
        .monospace {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <input type="text" id="chordInput" placeholder="Type a chord (e.g., Bb7, F#m7)" style="padding: 8px; font-size: 16px; border: 1px solid #ccc; border-radius: 4px;">
        <select id="rootSelect">
            <option value="C">C</option>
            <option value="Câ™¯">Câ™¯</option>
            <option value="Dâ™­">Dâ™­</option>
            <option value="D">D</option>
            <option value="Dâ™¯">Dâ™¯</option>
            <option value="Eâ™­">Eâ™­</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="Fâ™¯">Fâ™¯</option>
            <option value="Gâ™­">Gâ™­</option>
            <option value="G">G</option>
            <option value="Gâ™¯">Gâ™¯</option>
            <option value="Aâ™­">Aâ™­</option>
            <option value="A">A</option>
            <option value="Aâ™¯">Aâ™¯</option>
            <option value="Bâ™­">Bâ™­</option>
            <option value="B">B</option>
        </select>
        <select id="qualitySelect">
            <option value="">Select quality...</option>
        </select>
    </div>

    <div id="result" class="card" style="display: none">
        <div class="title" id="chordTitle"></div>
        <div class="content">
            <p id="fullName"></p>
            <p id="forteNumber"></p>
            <p id="intervals"></p>
            <p id="notes"></p>
            <p id="pcs"></p>
            <p id="aliases"></p>
            <div class="monospace">
                <p id="binary"></p>
                <p id="decimal"></p>
            </div>
        </div>
    </div>



	<!-- Replace the existing checkbox-container divs with this 
	<div class="controls-section" style="margin: 20px 0;">
		<h3>Export Options</h3>
		<div class="checkbox-container">
			<h4>Include Fields:</h4>
			<label><input type="checkbox" class="export-field" value="intervals" checked> Intervals</label>
			<label><input type="checkbox" class="export-field" value="fullName" checked> Full Name</label>
			<label><input type="checkbox" class="export-field" value="aliases" checked> Aliases</label>
			<label><input type="checkbox" class="export-field" value="forteNumber" checked> Forte Number</label>
			<label><input type="checkbox" class="export-field" value="namedInversions" checked> Named Inversions</label>
			<label><input type="checkbox" class="export-field" value="avoidNotes" checked> Avoid Notes</label>
			<label><input type="checkbox" class="export-field" value="compatibleScales" checked> Compatible Scales</label>
			<label><input type="checkbox" class="export-field" value="transpositions" id="transpositions-checkbox" checked> Transpositions</label>
		</div>
	
		<div id="transposition-options" class="checkbox-container" style="margin-left: 20px; display: block;">
			<h4>Transposition Fields:</h4>
			<label><input type="checkbox" class="transposition-field" value="notes" checked> Notes</label>
			<label><input type="checkbox" class="transposition-field" value="pcs" checked> Pitch Classes</label>
			<label><input type="checkbox" class="transposition-field" value="binary" checked> Binary</label>
			<label><input type="checkbox" class="transposition-field" value="decimal" checked> Decimal</label>
			<label><input type="checkbox" class="transposition-field" value="namedInversions" checked> Specific Inversions</label>
		</div>
	</div>

	<button onclick="exportChordDictionary()">Export JSON</button>
-->
	<style>
		.controls-section {
			background: #f5f5f5;
			padding: 15px;
			border-radius: 8px;
			margin-bottom: 20px;
		}
	
		.checkbox-container {
			display: flex;
			flex-wrap: wrap;
			gap: 10px;
			margin-top: 5px;
		}
	
		.checkbox-container label {
			display: flex;
			align-items: center;
			gap: 5px;
		}
	
		h4 {
			width: 100%;
			margin: 5px 0;
		}
	</style>

    <script>
        // Interval definitions for both pitch class and letter steps
        const intervalMap = {
            'R':    { letters: 0, semitones: 0 },
            'â™­2':   { letters: 1, semitones: 1 },
            '2':    { letters: 1, semitones: 2 },
            'â™­3':   { letters: 2, semitones: 3 },
            '3':    { letters: 2, semitones: 4 },
            '4':    { letters: 3, semitones: 5 },
            'â™¯4':   { letters: 3, semitones: 6 },
            'â™­5':   { letters: 4, semitones: 6 },
            '5':    { letters: 4, semitones: 7 },
            'â™¯5':   { letters: 4, semitones: 8 },
            'â™­6':   { letters: 5, semitones: 8 },
            '6':    { letters: 5, semitones: 9 },
            'ð„«7':   { letters: 6, semitones: 9 },
            'â™­7':   { letters: 6, semitones: 10 },
            '7':    { letters: 6, semitones: 11 },
            'â™­9':   { letters: 1, semitones: 1 },
            '9':    { letters: 1, semitones: 2 },
            'â™¯9':   { letters: 1, semitones: 3 },
            '11':   { letters: 3, semitones: 5 },
            'â™¯11':  { letters: 3, semitones: 6 },
            'â™­13':  { letters: 5, semitones: 8 },
            '13':   { letters: 5, semitones: 9 }
        };

        const qualitySelect = document.getElementById('qualitySelect');
        const rootSelect = document.getElementById('rootSelect');
        const resultDiv = document.getElementById('result');
        
        let chordData = {};

        function getPC(note) {
            const letterPCs = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
            const baseLetter = note[0];
            const basePC = letterPCs[baseLetter];
            
            if (note.includes('ð„«')) return (basePC - 2 + 12) % 12;
            if (note.includes('ð„ª')) return (basePC + 2) % 12;
            if (note.includes('â™­â™­')) return (basePC - 2 + 12) % 12;
            if (note.includes('â™¯')) return (basePC + 1) % 12;
            if (note.includes('â™­')) return (basePC - 1 + 12) % 12;
            return basePC;
        }

        function buildNoteFromInterval(root, interval) {
            const letters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
            const letterPCs = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
            
            // Get root letter index
            const rootIndex = letters.indexOf(root[0]);
            
            // Calculate target letter using interval's letter steps
            const targetLetterIndex = (rootIndex + interval.letters) % 7;
            const targetLetter = letters[targetLetterIndex];
            
            // Calculate target PC using root's PC plus interval's semitones
            const rootPC = getPC(root);
            const targetPC = (rootPC + interval.semitones) % 12;
            
            // Calculate needed alteration
            const naturalPC = letterPCs[targetLetter];
            const alteration = (targetPC - naturalPC + 12) % 12;
            
            // Return the note with appropriate accidental
            if (alteration === 0) return targetLetter;
            if (alteration === 1) return targetLetter + 'â™¯';
            if (alteration === 2) return targetLetter + 'ð„ª';
            if (alteration === 10) return targetLetter + 'ð„«';
            if (alteration === 11) return targetLetter + 'â™­';
            
            console.warn('Unexpected alteration:', alteration);
            return targetLetter;
        }

        function transposeChord(root, quality, chordData) {
            if (!chordData[quality]) return null;
            const chord = chordData[quality];

            // If root is C, use the exact notes from JSON
            if (root === 'C') {
                return {
                    ...chord,
                    notes: chord.notes,
                    pcs: chord.pcs,
                    binary: chord.binary,
                    decimal: chord.decimal
                };
            }

            // Build each note from intervals
            const transposedNotes = chord.intervals.map(intervalName => {
                const interval = intervalMap[intervalName];
                return buildNoteFromInterval(root, interval);
            });

            // Calculate pitch classes
            const pcs = transposedNotes.map(note => getPC(note));

            // Generate binary from PCs
            const binary = Array(12).fill('0');
            pcs.forEach(pc => binary[pc] = '1');
            const binaryStr = binary.join('');

            return {
                ...chord,
                notes: transposedNotes,
                pcs,
                binary: binaryStr,
                decimal: parseInt(binaryStr, 2)
            };
        }

        // Load chord dictionary
        fetch('chord_dictionary.json')
            .then(response => response.json())
            .then(data => {
                chordData = data;
                // Populate quality select
                Object.keys(data).sort().forEach(quality => {
                    const option = document.createElement('option');
                    option.value = quality;
                    option.textContent = quality;
                    qualitySelect.appendChild(option);
                });
            })
            .catch(error => console.error('Error loading chord data:', error));

        // Update display function
		function updateChordDisplay() {
			const root = rootSelect.value;
			const quality = qualitySelect.value;
	
			if (!quality) {
				resultDiv.style.display = 'none';
				return;
			}

			const chord = transposeChord(root, quality, chordData);
			if (!chord) return;

			const specificInversions = findSpecificInversions(root, quality, 
				['C', 'Câ™¯', 'Dâ™­', 'D', 'Dâ™¯', 'Eâ™­', 'E', 'F', 'Fâ™¯', 'Gâ™­', 'G', 'Gâ™¯', 'Aâ™­', 'A', 'Aâ™¯', 'Bâ™­', 'B'],
				chordData);

			document.getElementById('chordTitle').textContent = `${root}${quality}`;
			document.getElementById('fullName').textContent = `Full Name: ${chord.fullName}`;
			document.getElementById('forteNumber').textContent = `Forte Number: ${chord.forteNumber}`;
			document.getElementById('intervals').textContent = `Intervals: [${chord.intervals.join(', ')}]`;
			document.getElementById('notes').textContent = `Notes: [${chord.notes.join(', ')}]`;
			document.getElementById('pcs').textContent = `Pitch Classes: [${chord.pcs.join(', ')}]`;
			document.getElementById('aliases').textContent = `Aliases: [${chord.aliases.join(', ')}]`;
			document.getElementById('binary').textContent = `Binary: ${chord.binary}`;
			document.getElementById('decimal').textContent = `Decimal: ${chord.decimal}`;
	
			// Remove any existing inversions element
			const existingInversions = document.getElementById('inversions');
			if (existingInversions) {
				existingInversions.remove();
			}
	
			// Add new inversions if any exist
			if (specificInversions.length > 0) {
				// Separate alternative spellings (interval 0) from true inversions
				const altSpellings = specificInversions.filter(inv => inv.interval === 0);
				const trueInversions = specificInversions.filter(inv => inv.interval !== 0);
		
				// Create container for all inversion-related info
				const inversionsContainer = document.createElement('div');
				inversionsContainer.id = 'inversions';
		
				// Add alternative spellings if they exist
				if (altSpellings.length > 0) {
					const altElement = document.createElement('p');
					const altLines = altSpellings.map(alt => 
						`${alt.chord}, [${alt.notes.join(', ')}]`
					);
					altElement.innerHTML = `Alternative spellings:<br>${altLines.join('<br>')}`;
					inversionsContainer.appendChild(altElement);
				}
		
				// Add true inversions if they exist
				if (trueInversions.length > 0) {
					const invElement = document.createElement('p');
					const inversionLines = trueInversions.map(formatInversion);
					invElement.innerHTML = `Named Inversions:<br>${inversionLines.join('<br>')}`;
					inversionsContainer.appendChild(invElement);
				}
		
				document.getElementById('result').querySelector('.content').appendChild(inversionsContainer);
			}

			resultDiv.style.display = 'block';
		}


        rootSelect.addEventListener('change', updateChordDisplay);
        qualitySelect.addEventListener('change', updateChordDisplay);

        function findNamedInversions() {
            let decimalMap = {};
            let namedInversionsMap = {};

            const roots = ['C', 'Câ™¯', 'D', 'Dâ™¯', 'E', 'F', 'Fâ™¯', 'G', 'Gâ™¯', 'A', 'Aâ™¯', 'B'];
            const semitoneMap = {
                "C": 0, "Câ™¯": 1, "D": 2, "Dâ™¯": 3, "E": 4, "F": 5, "Fâ™¯": 6, 
                "G": 7, "Gâ™¯": 8, "A": 9, "Aâ™¯": 10, "B": 11
            };

            Object.keys(chordData).forEach(quality => {
                roots.forEach(root => {
                    let transposed = transposeChord(root, quality, chordData);
                    if (!transposed) return;

                    let decimal = transposed.decimal;
                    let chordIdentifier = root + " " + quality;

                    if (!decimalMap[decimal]) {
                        decimalMap[decimal] = [];
                    }
                    decimalMap[decimal].push({ root: root, quality: quality });
                });
            });

            Object.keys(decimalMap).forEach(decimal => {
                if (decimalMap[decimal].length > 1) {
                    let chords = decimalMap[decimal];

                    chords.forEach(chord => {
                        let chordQuality = chord.quality;
                        if (!namedInversionsMap[chordQuality]) {
                            namedInversionsMap[chordQuality] = [];
                        }

                        chords.forEach(otherChord => {
                            if (otherChord.quality !== chord.quality || otherChord.root !== chord.root) {
                                let interval = (semitoneMap[otherChord.root] - semitoneMap[chord.root] + 12) % 12;
                                let inversionEntry = `(${interval})${otherChord.quality}`;
                                if (!namedInversionsMap[chordQuality].includes(inversionEntry)) {
                                    namedInversionsMap[chordQuality].push(inversionEntry);
                                }
                            }
                        });
                    });
                }
            });

            return namedInversionsMap;
        }
        
        // Helper function to compare sets
		function setsEqual(set1, set2) {
			if (set1.size !== set2.size) return false;
			for (const item of set1) {
				if (!set2.has(item)) return false;
			}
			return true;
		}
		
		// Find specific inversions with full details
		function findSpecificInversions(root, quality, roots, chordData) {
			const inversions = [];
			const currentChord = transposeChord(root, quality, chordData);
			if (!currentChord) return inversions;

			const currentPCs = new Set(currentChord.pcs);
	
			roots.forEach(otherRoot => {
				Object.keys(chordData).forEach(otherQuality => {
					if (root === otherRoot && quality === otherQuality) return;
			
					const otherChord = transposeChord(otherRoot, otherQuality, chordData);
					if (!otherChord) return;

					const otherPCs = new Set(otherChord.pcs);
			
					// Check if pitch class sets are equal
					if (setsEqual(currentPCs, otherPCs)) {
						// Calculate interval between roots
						const interval = (getPC(otherRoot) - getPC(root) + 12) % 12;
				
						inversions.push({
							interval,
							chord: `${otherRoot}${otherQuality}`,
							intervals: otherChord.intervals,
							notes: otherChord.notes,
							pcs: otherChord.notes.map(note => getPC(note))
						});
					}
				});
			});

			// Sort by interval
			return inversions.sort((a, b) => a.interval - b.interval);
		}

		
		// Format inversion for display
		function formatInversion(inv) {
			return `(${inv.interval}), ${inv.chord}, [${inv.intervals.join(', ')}], [${inv.notes.join(', ')}], [${inv.pcs.join(', ')}]`;
		}

		// Update export function
		function exportChordDictionary() {
			const selectedFields = Array.from(document.querySelectorAll('.export-field:checked'))
				.map(checkbox => checkbox.value);

			const roots = ['C', 'Câ™¯', 'Dâ™­', 'D', 'Dâ™¯', 'Eâ™­', 'E', 'F', 'Fâ™¯', 'Gâ™­', 'G', 'Gâ™¯', 'Aâ™­', 'A', 'Aâ™¯', 'Bâ™­', 'B'];
			let exportData = {};

			Object.keys(chordData).forEach(quality => {
				let chord = chordData[quality];
				let exportedChord = {};

				selectedFields.forEach(field => {
					if (field !== "transpositions") {
						exportedChord[field] = chord[field];
					}
				});

				if (selectedFields.includes("transpositions")) {
					exportedChord.transpositions = {};
					roots.forEach(root => {
						let transposed = transposeChord(root, quality, chordData);
						if (!transposed) return;
				
						exportedChord.transpositions[root] = {
							intervals: transposed.intervals,
							notes: transposed.notes,
							pcs: transposed.pcs.sort((a, b) => a - b)
						};

						// Add specific inversions and alternative spellings if they exist
						const specificInversions = findSpecificInversions(root, quality, roots, chordData);
						if (specificInversions.length > 0) {
							const altSpellings = specificInversions
								.filter(inv => inv.interval === 0)
								.map(alt => ({
									chord: alt.chord,
									notes: alt.notes
								}));
					
							const trueInversions = specificInversions.filter(inv => inv.interval !== 0);
					
							if (altSpellings.length > 0) {
								exportedChord.transpositions[root].alternativeSpellings = altSpellings;
							}
					
							if (trueInversions.length > 0) {
								exportedChord.transpositions[root].namedInversions = trueInversions;
							}
						}
					});
				}

				exportData[quality] = exportedChord;
			});

			const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
			const url = URL.createObjectURL(jsonBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "chord_dictionary_export.json";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		
		
		


		document.getElementById('chordInput').addEventListener('keypress', function(e) {
			if (e.key === 'Enter') {
				const input = this.value.trim();
				if (!input) return;
		
				// Parse chord symbol BEFORE normalizing accidentals
				const match = input.match(/^([A-G][b#]?)(.*)$/);
				if (!match) return;
		
				const [_, rootRaw, qualityRaw] = match;
		
				// Now normalize accidentals for the root only
				const root = rootRaw.replace(/b/g, 'â™­').replace(/#/g, 'â™¯');
		
				// Keep quality as is for dictionary lookup
				const quality = qualityRaw;
		
				// Find the main quality - first check if it's a direct key
				let mainQuality = quality;
		
				if (!chordData[mainQuality]) {
					// If not a direct key, look through aliases
					for (let key in chordData) {
						if (chordData[key].aliases && 
							chordData[key].aliases.includes(quality)) {
							mainQuality = key;
							break;
						}
					}
				}
		
				// Update select elements if values exist
				if (rootSelect.querySelector(`option[value="${root}"]`) && 
					qualitySelect.querySelector(`option[value="${mainQuality}"]`)) {
					rootSelect.value = root;
					qualitySelect.value = mainQuality;
					updateChordDisplay();
				}
			}
		});




				

// 		document.getElementById('transpositions-checkbox').addEventListener('change', function() {
// 			document.getElementById('transposition-options').style.display = this.checked ? 'block' : 'none';
// 		});

</script>

</body>
</html>