<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Chord Dictionary</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
        }
        select {
            padding: 8px;
            font-size: 16px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .card {
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 20px;
            background-color: #fff;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .title {
            font-size: 24px;
            font-weight: bold;
            margin-bottom: 16px;
        }
        .content p {
            margin: 8px 0;
        }
        .monospace {
            font-family: monospace;
            background-color: #f5f5f5;
            padding: 8px;
            border-radius: 4px;
            margin-top: 16px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <select id="rootSelect">
            <option value="C">C</option>
            <option value="C♯">C♯</option>
            <option value="D♭">D♭</option>
            <option value="D">D</option>
            <option value="D♯">D♯</option>
            <option value="E♭">E♭</option>
            <option value="E">E</option>
            <option value="F">F</option>
            <option value="F♯">F♯</option>
            <option value="G♭">G♭</option>
            <option value="G">G</option>
            <option value="G♯">G♯</option>
            <option value="A♭">A♭</option>
            <option value="A">A</option>
            <option value="A♯">A♯</option>
            <option value="B♭">B♭</option>
            <option value="B">B</option>
        </select>
        <select id="qualitySelect">
            <option value="">Select quality...</option>
        </select>
    </div>
    <div id="result" class="card" style="display: none">
        <div class="title" id="chordTitle"></div>
        <div class="content">
            <p id="fullName"></p>
            <p id="forteNumber"></p>
            <p id="intervals"></p>
            <p id="notes"></p>
            <p id="pcs"></p>
            <p id="aliases"></p>
            <div class="monospace">
                <p id="binary"></p>
                <p id="decimal"></p>
            </div>
        </div>
    </div>
	<div class="checkbox-container">
		<label><input type="checkbox" class="export-field" value="intervals" checked> Intervals</label>
		<label><input type="checkbox" class="export-field" value="fullName" checked> Full Name</label>
		<label><input type="checkbox" class="export-field" value="aliases" checked> Aliases</label>
		<label><input type="checkbox" class="export-field" value="forteNumber" checked> Forte Number</label>
		<label><input type="checkbox" class="export-field" value="namedInversions" checked> Named Inversions</label>
		<label><input type="checkbox" class="export-field" value="avoidNotes" checked> Avoid Notes</label>
		<label><input type="checkbox" class="export-field" value="compatibleScales" checked> Compatible Scales</label>
		<label><input type="checkbox" class="export-field" value="transpositions" id="transpositions-checkbox" checked> Transpositions</label>
	</div>

	<div id="transposition-options" class="checkbox-container" style="margin-left: 20px; display: block;">
		<label><input type="checkbox" class="transposition-field" value="notes" checked> Notes</label>
		<label><input type="checkbox" class="transposition-field" value="pcs" checked> Pitch Classes</label>
		<label><input type="checkbox" class="transposition-field" value="binary" checked> Binary</label>
		<label><input type="checkbox" class="transposition-field" value="decimal" checked> Decimal</label>
	</div>

	<button onclick="exportChordDictionary()">Export JSON</button>

    <script>
        const intervalToPc = {
            'R': 0, '♭2': 1, '2': 2, '♭3': 3, '3': 4, '4': 5, '♯4': 6,
            '♭5': 6, '5': 7, '♯5': 8, '♭6': 8, '6': 9, '♭7': 10, '7': 11,
            '𝄫7': 9, '♭9': 1, '9': 2, '♯9': 3, '11': 5, '♯11': 6, '♭13': 8, '13': 9
        };
		const qualitySelect = document.getElementById('qualitySelect');
		const rootSelect = document.getElementById('rootSelect');
		const resultDiv = document.getElementById('result');

		let chordData = {};

		// Load chord dictionary
		fetch('chord_dictionary.json')
			.then(response => response.json())
			.then(data => {
				chordData = data;
				// Populate quality select
				Object.keys(data).sort().forEach(quality => {
					const option = document.createElement('option');
					option.value = quality;
					option.textContent = quality;
					qualitySelect.appendChild(option);
				});
			})
			.catch(error => console.error('Error loading chord data:', error));

        function getPC(note) {
            // Handle double accidentals
            if (note.includes('𝄪') || note.includes('♯♯')) {
                const baseLetter = note[0];
                const basePC = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 }[baseLetter];
                return (basePC + 2) % 12;
            }
            if (note.includes('♭♭')) {
                const baseLetter = note[0];
                const basePC = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 }[baseLetter];
                return (basePC - 2 + 12) % 12;
            }

            // Handle single accidentals
            const letter = note[0];
            const basePC = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 }[letter];
            
            if (note.includes('♯')) return (basePC + 1) % 12;
            if (note.includes('♭')) return (basePC - 1 + 12) % 12;
            return basePC;
        }
        
        function transposeNote(root, cNote) {
			if (root === 'C') return cNote;

			// Special handling for double-flat seventh
			if (cNote.includes('𝄫')) {
				const letters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
				const rootLetterIndex = letters.indexOf(root[0]);
				// For diminished seventh, we want the seventh letter name
				const targetLetterIndex = (rootLetterIndex + 6) % 7;  // +6 for seventh
				const targetLetter = letters[targetLetterIndex];
				return targetLetter + '♭';  // Always flat for diminished seventh
			}

			const interval = getPC(cNote);
			const rootPC = getPC(root);
			const targetPC = (interval + rootPC) % 12;

			// Get letter name based on root letter
			const letters = ['C', 'D', 'E', 'F', 'G', 'A', 'B'];
			const rootLetterIndex = letters.indexOf(root[0]);
			const cNoteLetterIndex = letters.indexOf(cNote[0]);
			const targetLetterIndex = (rootLetterIndex + cNoteLetterIndex) % 7;
			const targetLetter = letters[targetLetterIndex];

			// Calculate required accidentals
			const naturalPC = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 }[targetLetter];
			const needed = (targetPC - naturalPC + 12) % 12;

			// Map the pitch class difference to the appropriate accidental
			switch (needed) {
				case 0:  // No accidental needed
					return targetLetter;
				case 1:  // Sharp
					return targetLetter + '♯';
				case 2:  // Double sharp
					return targetLetter + '𝄪';
				case 3:  // Triple sharp
					return targetLetter + '♯𝄪';
				case 10: // Double flat
					return targetLetter + '♭♭';
				case 11: // Flat
					return targetLetter + '♭';
				default:
					console.warn('Unexpected accidental:', needed, 'for note:', targetLetter);
					return targetLetter;
			}
		}

		function transposeChord(root, quality, chordData) {
				if (!chordData[quality]) return null;
				const chord = chordData[quality];

				// If root is C, use the exact notes from JSON
				if (root === 'C') {
					return {
						...chord,
						notes: chord.notes,
						pcs: chord.pcs,
						binary: chord.binary,
						decimal: chord.decimal
					};
				}

				// Otherwise transpose from C
				const transposedNotes = chord.notes.map(cNote => transposeNote(root, cNote));
				const pcs = transposedNotes.map(note => getPC(note));
			
				// Generate binary from PCs
				const binary = Array(12).fill('0');
				pcs.forEach(pc => binary[pc] = '1');
				const binaryStr = binary.join('');
			
				return {
					...chord,
					notes: transposedNotes,
					pcs,
					binary: binaryStr,
					decimal: parseInt(binaryStr, 2)
				};
			}

		function updateChordDisplay() {
			const root = rootSelect.value;
			const quality = qualitySelect.value;
		
			if (!quality) {
				resultDiv.style.display = 'none';
				return;
			}

			const chord = transposeChord(root, quality, chordData);
			if (!chord) return;

			document.getElementById('chordTitle').textContent = `${root}${quality}`;
			document.getElementById('fullName').textContent = `Full Name: ${chord.fullName}`;
			document.getElementById('forteNumber').textContent = `Forte Number: ${chord.forteNumber}`;
			document.getElementById('intervals').textContent = `Intervals: [${chord.intervals.join(', ')}]`;
			document.getElementById('notes').textContent = `Notes: [${chord.notes.join(', ')}]`;
			document.getElementById('pcs').textContent = `Pitch Classes: [${chord.pcs.join(', ')}]`;
			document.getElementById('aliases').textContent = `Aliases: [${chord.aliases.join(', ')}]`;
			document.getElementById('binary').textContent = `Binary: ${chord.binary}`;
			document.getElementById('decimal').textContent = `Decimal: ${chord.decimal}`;

			resultDiv.style.display = 'block';
		}

		rootSelect.addEventListener('change', updateChordDisplay);
		qualitySelect.addEventListener('change', updateChordDisplay);

		function exportChordDictionary() {
			const selectedFields = Array.from(document.querySelectorAll('.export-field:checked'))
				.map(checkbox => checkbox.value);

			const transpositionFields = Array.from(document.querySelectorAll('.transposition-field:checked'))
				.map(checkbox => checkbox.value);

			const roots = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
			let exportData = {};

			Object.keys(chordData).forEach(quality => {
				let chord = chordData[quality];
				let exportedChord = {};

				selectedFields.forEach(field => {
					if (field !== "transpositions") {
						exportedChord[field] = chord[field];
					}
				});

				if (selectedFields.includes("transpositions")) {
					exportedChord.transpositions = {};
					roots.forEach(root => {
						let transposed = transposeChord(root, quality, chordData);
						exportedChord.transpositions[root] = {};

						transpositionFields.forEach(tField => {
							exportedChord.transpositions[root][tField] = transposed[tField];
						});
					});
				}

				exportData[quality] = exportedChord;
			});

			const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
			const url = URL.createObjectURL(jsonBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "chord_dictionary_export.json";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		// Update named inversions before export
		function exportChordDictionary() {
			let namedInversionsMap = findNamedInversions();
	
			const selectedFields = Array.from(document.querySelectorAll('.export-field:checked'))
				.map(checkbox => checkbox.value);

			const transpositionFields = Array.from(document.querySelectorAll('.transposition-field:checked'))
				.map(checkbox => checkbox.value);

			const roots = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
			let exportData = {};

			Object.keys(chordData).forEach(quality => {
				let chord = chordData[quality];
				let exportedChord = {};

				selectedFields.forEach(field => {
					if (field !== "transpositions") {
						exportedChord[field] = chord[field];
					}
				});

				if (selectedFields.includes("transpositions")) {
					exportedChord.transpositions = {};
					roots.forEach(root => {
						let transposed = transposeChord(root, quality, chordData);
						exportedChord.transpositions[root] = {};

						transpositionFields.forEach(tField => {
							exportedChord.transpositions[root][tField] = transposed[tField];
						});
					});
				}

				let chordName = "C" + quality;  // The standard representation in the dictionary
				if (namedInversionsMap[chordName]) {
					exportedChord.namedInversions = namedInversionsMap[chordName];
				}

				exportData[quality] = exportedChord;
			});

			const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
			const url = URL.createObjectURL(jsonBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "chord_dictionary_export.json";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		function findNamedInversions() {
			let decimalMap = {};
			let namedInversionsMap = {};

			const roots = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
			const semitoneMap = {
				"C": 0, "C♯": 1, "D": 2, "D♯": 3, "E": 4, "F": 5, "F♯": 6, 
				"G": 7, "G♯": 8, "A": 9, "A♯": 10, "B": 11
			};

			Object.keys(chordData).forEach(quality => {
				roots.forEach(root => {
					let transposed = transposeChord(root, quality, chordData);
					if (!transposed) return;

					let decimal = transposed.decimal;
					let chordIdentifier = root + " " + quality;

					if (!decimalMap[decimal]) {
						decimalMap[decimal] = [];
					}
					decimalMap[decimal].push({ root: root, quality: quality });
				});
			});

			// Populate named inversions and update UI
			let namedInversionsHTML = "";
			Object.keys(decimalMap).forEach(decimal => {
				if (decimalMap[decimal].length > 1) {
					let chords = decimalMap[decimal];

					chords.forEach(chord => {
						let chordQuality = chord.quality;
						if (!namedInversionsMap[chordQuality]) {
							namedInversionsMap[chordQuality] = [];
						}

						chords.forEach(otherChord => {
							if (otherChord.quality !== chord.quality || otherChord.root !== chord.root) {
								let interval = (semitoneMap[otherChord.root] - semitoneMap[chord.root] + 12) % 12;
								let inversionEntry = `(${interval})${otherChord.quality}`;
								if (!namedInversionsMap[chordQuality].includes(inversionEntry)) {
									namedInversionsMap[chordQuality].push(inversionEntry);
								}
							}
						});
					});
				}
			});

			return namedInversionsMap;
		}

		// Update named inversions before export
		function exportChordDictionary() {
			let namedInversionsMap = findNamedInversions();
	
			const selectedFields = Array.from(document.querySelectorAll('.export-field:checked'))
				.map(checkbox => checkbox.value);

			const transpositionFields = Array.from(document.querySelectorAll('.transposition-field:checked'))
				.map(checkbox => checkbox.value);

			const roots = ['C', 'C♯', 'D', 'D♯', 'E', 'F', 'F♯', 'G', 'G♯', 'A', 'A♯', 'B'];
			let exportData = {};

			Object.keys(chordData).forEach(quality => {
				let chord = chordData[quality];
				let exportedChord = {};

				selectedFields.forEach(field => {
					if (field !== "transpositions") {
						exportedChord[field] = chord[field];
					}
				});

				if (selectedFields.includes("transpositions")) {
					exportedChord.transpositions = {};
					roots.forEach(root => {
						let transposed = transposeChord(root, quality, chordData);
						exportedChord.transpositions[root] = {};

						transpositionFields.forEach(tField => {
							exportedChord.transpositions[root][tField] = transposed[tField];
						});
					});
				}

				if (namedInversionsMap[quality]) {
					exportedChord.namedInversions = namedInversionsMap[quality];
				}

				exportData[quality] = exportedChord;
			});

			const jsonBlob = new Blob([JSON.stringify(exportData, null, 2)], { type: "application/json" });
			const url = URL.createObjectURL(jsonBlob);
			const link = document.createElement("a");
			link.href = url;
			link.download = "chord_dictionary_export.json";
			document.body.appendChild(link);
			link.click();
			document.body.removeChild(link);
		}

		document.getElementById('transpositions-checkbox').addEventListener('change', function() {
			document.getElementById('transposition-options').style.display = this.checked ? 'block' : 'none';
		});

</script>

</body>
</html>